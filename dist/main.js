/*! For license information please see main.js.LICENSE.txt */
module.exports=function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=79)}([function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReportController=void 0;exports.ReportController=class{static log(message){console.log(message)}static email(message,cooldown=0){console.log(message),null!=Memory.myMemory.reports[message]&&(new Date).getTime()<Memory.myMemory.reports[message]||(cooldown>0&&(Memory.myMemory.reports[message]=(new Date).getTime()+cooldown),Game.notify(Game.time+": "+message))}static niceDateFormat(date){const localDate=new Date(date.toLocaleString("en-US",{timeZone:"Australia/Melbourne"}));return localDate.getMonth()+1+"-"+localDate.getDate()+" "+localDate.getHours()+":"+localDate.getMinutes()+":"+localDate.getSeconds()}static timeSince(date){let secondsLeft=Math.floor(((new Date).getTime()-date.getTime())/1e3),result="";if(secondsLeft>=604800){const weeks=Math.floor(secondsLeft/604800);secondsLeft-=604800*weeks,result+=weeks+"w, "}if(secondsLeft>=86400){const days=Math.floor(secondsLeft/86400);secondsLeft-=86400*days,result+=days+"d, "}if(secondsLeft>=3600){const hours=Math.floor(secondsLeft/3600);secondsLeft-=3600*hours,result+=hours+"h, "}if(secondsLeft>=60){const minutes=Math.floor(secondsLeft/60);secondsLeft-=60*minutes,result+=minutes+"m, "}return secondsLeft>=0&&(result+=secondsLeft+"s"),result+=" ago",result}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LogHelper=void 0;exports.LogHelper=class{static logTable(table){const maxColumnWidth=[];for(let columnIndex=0;columnIndex<table[0].length;columnIndex++){maxColumnWidth[columnIndex]=0;for(let rowIndex=0;rowIndex<table.length;rowIndex++){const length=table[rowIndex][columnIndex].length;length>maxColumnWidth[columnIndex]&&(maxColumnWidth[columnIndex]=length+1)}}for(let rowIndex=0;rowIndex<table.length;rowIndex++){let rowAsString="";for(let columnIndex=0;columnIndex<table[rowIndex].length;columnIndex++){const dataInCell=table[rowIndex][columnIndex];rowAsString+=dataInCell;const spacesToAdd=maxColumnWidth[columnIndex]-dataInCell.length;for(let spacesToFill=0;spacesToFill<spacesToAdd;spacesToFill++)rowAsString+=" "}console.log(rowAsString)}}static logPos(myRoomPos){return"[room "+myRoomPos.roomName+" pos "+myRoomPos.x+","+myRoomPos.y+"]"}static roomNameAsLink(roomName){return"<a href='#!/room/"+Game.shard.name+"/"+roomName+"'>"+roomName+"</a>"}static markTarget(pos){49!==pos.x&&0!==pos.x&&0!==pos.y&&49!==pos.y&&(new RoomVisual(pos.roomName).line(pos.x-1,pos.y,pos.x+1,pos.y,{color:"red"}),new RoomVisual(pos.roomName).line(pos.x,pos.y-1,pos.x,pos.y+1,{color:"red"}),new RoomVisual(pos.roomName).circle(pos.x,pos.y,{stroke:"red",fill:"transparent",radius:.5}),new RoomVisual(pos.roomName).circle(pos.x,pos.y,{stroke:"red",fill:"transparent",radius:1}))}static logScreepsReturnCode(screepsReturnCode){switch(screepsReturnCode){case OK:return"OK";case ERR_NOT_OWNER:return"ERR_NOT_OWNER";case ERR_NO_PATH:return"ERR_NO_PATH";case ERR_BUSY:return"ERR_BUSY";case ERR_NAME_EXISTS:return"ERR_NAME_EXISTS";case ERR_NOT_FOUND:return"ERR_NOT_FOUND";case ERR_NOT_ENOUGH_RESOURCES:return"ERR_NOT_ENOUGH_RESOURCES";case ERR_NOT_ENOUGH_ENERGY:return"ERR_NOT_ENOUGH_ENERGY";case ERR_INVALID_TARGET:return"ERR_INVALID_TARGET";case ERR_FULL:return"ERR_FULL";case ERR_NOT_IN_RANGE:return"ERR_NOT_IN_RANGE";case ERR_INVALID_ARGS:return"ERR_INVALID_ARGS";case ERR_TIRED:return"ERR_TIRED";case ERR_NO_BODYPART:return"ERR_NO_BODYPART";case ERR_NOT_ENOUGH_EXTENSIONS:return"ERR_NOT_ENOUGH_EXTENSIONS";case ERR_RCL_NOT_ENOUGH:return"ERR_RCL_NOT_ENOUGH";case ERR_GCL_NOT_ENOUGH:return"ERR_GCL_NOT_ENOUGH"}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomHelper=void 0;exports.RoomHelper=class{static getMyRoomByName(name){for(let j=0;j<Memory.myMemory.myRooms.length;j++)if(Memory.myMemory.myRooms[j].name===name)return Memory.myMemory.myRooms[j];return null}static getRoomNameAsInterface(roomName){const result={roomName:roomName,xNum:-1,yNum:-1,xChar:"",yChar:""},splitResult=roomName.split(/[NSEW]/g);splitResult.splice(0,1);const letters=roomName.replace(/[0-9]/g,"");return result.xNum=Number(splitResult[0]),result.yNum=Number(splitResult[1]),result.xChar=letters[0],result.yChar=letters[1],result}static getRoomNameAsString(myRoomName){return myRoomName.xChar+myRoomName.xNum+myRoomName.yChar+myRoomName.yNum}static areaAroundPos(pos,room){let result=8;const terrain=room.getTerrain(),roomPositionsAround=[];roomPositionsAround.push({x:pos.x,y:pos.y-1}),roomPositionsAround.push({x:pos.x,y:pos.y+1}),roomPositionsAround.push({x:pos.x-1,y:pos.y}),roomPositionsAround.push({x:pos.x+1,y:pos.y}),roomPositionsAround.push({x:pos.x-1,y:pos.y-1}),roomPositionsAround.push({x:pos.x-1,y:pos.y+1}),roomPositionsAround.push({x:pos.x+1,y:pos.y+1}),roomPositionsAround.push({x:pos.x+1,y:pos.y-1});for(let i=0;i<8;i++)terrain.get(roomPositionsAround[i].x,roomPositionsAround[i].y)===TERRAIN_MASK_WALL&&result--;return result}static amountOfStructure(room,structureConstant){return room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===structureConstant}).length}static roomPosToMyPos(roomPos){return{x:roomPos.x,y:roomPos.y,roomName:roomPos.roomName}}static myPosToRoomPos(myPos){return new RoomPosition(myPos.x,myPos.y,myPos.roomName)}static posMatches(pos,myPos){return null!=myPos&&pos.roomName===myPos.roomName&&pos.x===myPos.x&&pos.y===myPos.y}static posMatches2(myPos1,myPos2){return null!=myPos1&&null!=myPos2&&myPos1.roomName===myPos2.roomName&&myPos1.x===myPos2.x&&myPos1.y===myPos2.y}static posMatches3(pos1,pos2){return null!=pos1&&null!=pos2&&pos1.roomName===pos2.roomName&&pos1.x===pos2.x&&pos1.y===pos2.y}static getMyRoomsAtOrAboveStage(stage){const result=[];for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myRoom=Memory.myMemory.myRooms[i];myRoom.roomStage>=stage&&result.push(myRoom)}return result}static structureHasResources(structure){if(structure.structureType===STRUCTURE_EXTENSION)return structure.store.getUsedCapacity(RESOURCE_ENERGY)>0;if(structure.structureType===STRUCTURE_FACTORY)return structure.store.getUsedCapacity()>0;if(structure.structureType===STRUCTURE_LAB)return Object.keys(structure.store).length>0;if(structure.structureType===STRUCTURE_LINK)return structure.store.getUsedCapacity(RESOURCE_ENERGY)>0;if(structure.structureType===STRUCTURE_NUKER){if(structure.store.getUsedCapacity(RESOURCE_ENERGY)>0)return!0;const ghodiumOxide=structure.store.getUsedCapacity(RESOURCE_GHODIUM_OXIDE);return null!=ghodiumOxide&&ghodiumOxide>0}return structure.structureType===STRUCTURE_POWER_SPAWN?structure.store.getUsedCapacity(RESOURCE_ENERGY)>0||structure.store.getUsedCapacity(RESOURCE_POWER)>0:structure.structureType===STRUCTURE_SPAWN?structure.store.getUsedCapacity(RESOURCE_ENERGY)>0:structure.structureType===STRUCTURE_STORAGE?Object.keys(structure.store).length>0:structure.structureType===STRUCTURE_TERMINAL?structure.store.getUsedCapacity()>0:structure.structureType===STRUCTURE_TOWER?structure.store.getUsedCapacity(RESOURCE_ENERGY)>0:structure.structureType===STRUCTURE_CONTAINER&&structure.store.getUsedCapacity()>0}static getPosOnOtherSide(pos1,middlePos){let resultX,resultY;return pos1.x===middlePos.x?(resultX=pos1.x,resultY=pos1.y>middlePos.y?middlePos.y-1:middlePos.y+1):pos1.y===middlePos.y?(resultY=pos1.y,resultX=pos1.x>middlePos.x?middlePos.x-1:middlePos.x+1):(resultY=pos1.y>middlePos.y?middlePos.y-1:middlePos.y+1,resultX=pos1.x>middlePos.x?middlePos.x-1:middlePos.x+1),new RoomPosition(resultX,resultY,pos1.roomName)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CreepHelper=void 0;const movement_helper_1=__webpack_require__(7);exports.CreepHelper=class{static getName(){const toReturn="c"+Memory.myMemory.globalId;return Memory.myMemory.globalId++,toReturn}static generateBody(baseBody,bodyPartsToAdd,room,useBest,maxBodySize=50,fillWithTough=!1){const maxEnergyToUse=useBest?room.energyCapacityAvailable:room.energyAvailable;let body=baseBody;for(;this.bodyCost(body)+this.bodyCost(bodyPartsToAdd)<=maxEnergyToUse&&body.length+bodyPartsToAdd.length<=maxBodySize;)body=body.concat(bodyPartsToAdd);if(fillWithTough){const toughtPart=[TOUGH];for(;this.bodyCost(body)+this.bodyCost(toughtPart)<=maxEnergyToUse&&body.length+1<=maxBodySize;)body=toughtPart.concat(body)}return body}static handleCreepPreRole(myCreep){return!!this.creepQueuedOrSpawning(myCreep)||myCreep.assignedRoomName!==Game.creeps[myCreep.name].room.name&&(Game.creeps[myCreep.name].say("Traveling"),movement_helper_1.MovementHelper.getCreepToRoom(Game.creeps[myCreep.name],myCreep,myCreep.assignedRoomName),!0)}static creepQueuedOrSpawning(myCreep){if("alive"===myCreep.spawningStatus)return!1;if("queued"===myCreep.spawningStatus&&null!=Game.creeps[myCreep.name])return myCreep.spawningStatus="spawning",!0;if("spawning"===myCreep.spawningStatus&&null!=Game.creeps[myCreep.name].ticksToLive){if(myCreep.spawningStatus="alive","Miner"===myCreep.role){const creep=Game.creeps[myCreep.name];let workCount=0;for(let i=0;i<creep.body.length;i++)creep.body[i].type===WORK&&workCount++;myCreep.amountOfWork=workCount}return!1}return!0}static bodyCost(body){return body.reduce((function(cost,part){return cost+BODYPART_COST[part]}),0)}static creepContainsBodyPart(creep,bodyPart){for(let i=0;i<creep.body.length;i++){if(creep.body[i].type===bodyPart)return!0}return!1}static creepContainsBodyParts(creep,bodyParts){for(let i=0;i<creep.body.length;i++){const currentBodyPart=creep.body[i];for(let j=0;j<bodyParts.length;j++)if(currentBodyPart.type===bodyParts[j])return!0}return!1}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Constants=void 0;class Constants{}exports.Constants=Constants,Constants.LABORERS_UPGRADE_WHEN_CONTROLLER_BENEATH=5e3,Constants.STAGE_8_SPAWN_LABORERS_WHEN_CONTROLLER_BENEATH=25e3,Constants.STAGE_8_SPAWN_UPGRADERS_WHEN_CONTROLLER_BENEATH=5e4,Constants.CONSCRIPTION_QUICK_MINIMUM_STAGE=1,Constants.SCAVENGE_MIN_STAGE=8,Constants.BANK_LINKED_STAGE=5.4,Constants.CONSCRIPTION_PRESSURE_MINIMUM_STAGE=6,Constants.MINERAL_START_STAGE=6,Constants.CONTROLLER_LINKED_STAGE=6.8,Constants.POWER_BANK_ROOM_STAGE=8,Constants.STAGE_8_ONE_SOURCE_ENERGY_DONATE_TARGET=5e4,Constants.STAGE_8_DONATE_AMOUNT=5e4,Constants.POWER_BANK_MIN_ENERGY=5e4,Constants.POWER_SPAWN_MIN_ENERGY=5e4,Constants.STAGE_8_DONATE_AT=1e5,Constants.AMOUNT_OF_BANK_ENERGY_TO_SPAWN_LABORER=1e5,Constants.AMOUNT_OF_BANK_ENERGY_REQUIRED_TO_SPAWN_UPGRADER=1e5,Constants.DONT_STOCK_NUKER_IF_ENERGY_UNDER=1e5,Constants.AMOUNT_OF_BANK_ENERGY_TO_SPAWN_LABORER_STAGE_8=2e5,Constants.DONT_DONATE_TO_ROOMS_WITH_ABOVE_ENERGY=25e4,Constants.DONT_RUN_REACTIONS_WHEN_BUCKET_UNDER=4e3,Constants.GENERATE_PIXEL_WHEN_BUCKET_OVER=9500,Constants.MAX_STOCKERS=1,Constants.MIN_LABORERS=1,Constants.LABORERS_NO_SPAWN=2,Constants.MAX_LABORERS_STAGE_8=2,Constants.MAX_LABORERS=3,Constants.LABORERS_BEFORE_BANK=3,Constants.WALL_AND_RAMPART_GOAL_HEALTH=5e5,Constants.CONSCRIPTION_RANGE=9,Constants.POWER_BANK_RANGE_MAX=5,Constants.SCAVENGE_MAX_DISTANCE=11,Constants.LINK_TRANSFER_AT=400,Constants.LINK_CONTROLLER_GOAL_ENERGY=600,Constants.STOCK_TOWER_TO=900,Constants.TERMINAL_GOAL_ENERGY=2e4,Constants.POWER_SPAWN_RESTOCK_WHEN_ENERGY_BELOW=3800,Constants.POWER_BANK_CLOSEST_STORAGE_POWER_BELOW=1e4,Constants.PERCENT_OF_CACHE_ENERGY_TO_SPAWN_HAULER=.5,Constants.POWER_BANK_TTL_MIN=4800,Constants.POWER_BANK_MAX_BANKS_AT_ONE_TIME=1,Constants.POWER_BANK_MAX_DAMAGE_PER_TICK_PER_AREA=840,Constants.POWER_BANK_AREA_AROUND_BANK_MIN=2,Constants.POWER_BANK_MIN_POWER=1500,Constants.POWER_BANK_DUO_TICKS_TO_SPAWN=141,Constants.REPAIR_ONLY_ON_ODD_THOUSAND=!0,Constants.BANK_LINKER_CAPACITY=100,Constants.LAB_REACTION_AMOUNT_TO_CEIL_TO=100,Constants.RALLY_FLAG_RANGE=3,Constants.UPGRADER_TICKS_TO_SPAWN=72,Constants.SCAVENGE_CARRY_PER_CREEP=25,Constants.SUICIDE_STOCKER_WHEN_TTL_BELOW=50},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.StageFunctions=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6);exports.StageFunctions=class{static buildExtensions(myRoom,room,numberOfExtensionsToBuild){const flags=flag_helper_1.FlagHelper.getFlags2(["ex"],room.name,numberOfExtensionsToBuild);let placedAtleastOne=!1;for(let i=0;i<flags.length;i++){const roomFlag=flags[i],flagNameSplit=roomFlag.name.split("-");if(Number(flagNameSplit[1])<=numberOfExtensionsToBuild){const result=Game.rooms[myRoom.name].createConstructionSite(roomFlag.pos,STRUCTURE_EXTENSION);result===OK?(report_controller_1.ReportController.log("Placed extension construction site in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),roomFlag.remove(),placedAtleastOne=!0):result!==ERR_RCL_NOT_ENOUGH&&report_controller_1.ReportController.email("ERROR: Placing a extension construction site errored "+result+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}}!placedAtleastOne&&0===Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<numberOfExtensionsToBuild&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs more extension flags (up to ex-"+numberOfExtensionsToBuild.toString()+")",report_cooldown_constants_1.ReportCooldownConstants.DAY)}static buildTowers(myRoom,room,numberOfTowersToBuild){const flags=flag_helper_1.FlagHelper.getFlags2(["tower"],room.name,numberOfTowersToBuild);let placedOne=!1;for(let i=0;i<flags.length;i++){const flag=flags[i];Game.rooms[myRoom.name].createConstructionSite(flag.pos,STRUCTURE_TOWER)===OK?(report_controller_1.ReportController.log("Placed tower construction site in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),flag.remove(),placedOne=!0):report_controller_1.ReportController.email("ERROR: Placing a tower construction site errored in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}0===Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)<numberOfTowersToBuild&&!placedOne&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs more tower flags (up to tower-"+numberOfTowersToBuild+")",report_cooldown_constants_1.ReportCooldownConstants.DAY)}static setupSourceLink(myRoom){const flags=flag_helper_1.FlagHelper.getFlags1(["link","source"],myRoom.name);let placedFully=!1;for(let i=0;i<flags.length;i++){const flag=flags[i];if(Game.rooms[myRoom.name].createConstructionSite(flag.pos,STRUCTURE_LINK)===OK){for(let j=0;j<myRoom.mySources.length;j++){const mySource=myRoom.mySources[j],source=Game.getObjectById(mySource.id);null==source?report_controller_1.ReportController.email("ERROR: Source was null when trying to get it by ID in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)):source.pos.inRangeTo(flag.pos,2)&&(mySource.link={pos:room_helper_1.RoomHelper.roomPosToMyPos(flag.pos),id:null},placedFully=!0)}placedFully?(report_controller_1.ReportController.log("Placed source link construction site in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),flag.remove()):report_controller_1.ReportController.email("ERROR: Placed a construction site at a flag but couldn't find a source to give it to in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}}for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(null!=mySource.link&&null==mySource.link.id){const structures=room_helper_1.RoomHelper.myPosToRoomPos(mySource.link.pos).lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_LINK){mySource.link.id=structures[j].id,mySource.state="Link";break}}}placedFully||0!==Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length||report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs source link flag (link-source-X)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}static clearHaulersAndCaches(myRoom){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if("Link"===mySource.state&&null!=mySource.link&&null!=mySource.link.id){if(null!=mySource.haulerName){const creep=Game.creeps[mySource.haulerName];null!=creep&&(creep.say("dthb4dshnr"),creep.suicide()),mySource.haulerName=null}if(null!=mySource.minerName){const creep=Game.creeps[mySource.minerName];null!=creep&&0===creep.getActiveBodyparts(CARRY)&&(creep.say("dthb4dshnr"),creep.suicide())}if(null!=mySource.cache&&null!=mySource.cache.id){const cache=Game.getObjectById(mySource.cache.id);null==cache||cache.destroy(),mySource.cache.id=null}}}}static buildSpawns(myRoom,room,amount){const flags=flag_helper_1.FlagHelper.getFlags1(["spawn"],myRoom.name);let placedSpawn=!1;if(1===flags.length){flags[0].pos.createConstructionSite(STRUCTURE_SPAWN)===OK&&(placedSpawn=!0,flags[0].remove())}!placedSpawn&&0===room.find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)<amount&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs a spawn flag (spawn)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReportCooldownConstants=void 0;class ReportCooldownConstants{}exports.ReportCooldownConstants=ReportCooldownConstants,ReportCooldownConstants.WEEK=6048e5,ReportCooldownConstants.DAY=864e5,ReportCooldownConstants.HOUR=36e5,ReportCooldownConstants.FIVE_MINUTE=3e5,ReportCooldownConstants.MINUTE=6e4},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MovementHelper=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2);class MovementHelper{static myMoveTo(creep,moveTo,myCreep){if(creep.fatigue>0)return ERR_TIRED;const currentCreepPos=room_helper_1.RoomHelper.roomPosToMyPos(creep.pos);return room_helper_1.RoomHelper.posMatches(moveTo,myCreep.roomMoveTarget.pos)&&!room_helper_1.RoomHelper.posMatches2(myCreep.lastPos,currentCreepPos)?(myCreep.lastPos=currentCreepPos,creep.moveByPath(myCreep.roomMoveTarget.path)):(myCreep.lastPos=currentCreepPos,myCreep.roomMoveTarget.pos=room_helper_1.RoomHelper.roomPosToMyPos(moveTo),myCreep.roomMoveTarget.path=creep.pos.findPathTo(moveTo,{maxRooms:1}),creep.moveByPath(myCreep.roomMoveTarget.path))}static getCreepToRoom(creep,creepMemory,roomName){if(null==creepMemory.interRoomTravelCurrentTarget||creep.pos.roomName!==creepMemory.interRoomTravelCurrentTarget.roomName){const target=this.getInterRoomTravelPathTarget(creep.pos,roomName);if(null==target)return;creepMemory.interRoomTravelCurrentTarget=room_helper_1.RoomHelper.roomPosToMyPos(target)}MovementHelper.myMoveTo(creep,room_helper_1.RoomHelper.myPosToRoomPos(creepMemory.interRoomTravelCurrentTarget),creepMemory)}static avoidEdges(costMatrix,room){room.find(FIND_EXIT).forEach(exitPos=>{costMatrix.set(exitPos.x,exitPos.y,1/0)})}static getInterRoomTravelPathTarget(currentPos,toRoomName){const fromRoomName=currentPos.roomName,result1=Game.map.findRoute(fromRoomName,toRoomName,{routeCallback:(room2,room1)=>Memory.myMemory.empire.avoidRooms.includes(room2)&&toRoomName!==room2?1/0:1});if(result1===ERR_NO_PATH)return report_controller_1.ReportController.email("ERROR: getInterRoomTravelPath got ERRO_NO_PATH for "+log_helper_1.LogHelper.roomNameAsLink(fromRoomName)+" to "+log_helper_1.LogHelper.roomNameAsLink(toRoomName)),null;if(result1.length<=0)return report_controller_1.ReportController.email("ERROR: getInterRoomTravelPath length <= 0 for "+log_helper_1.LogHelper.roomNameAsLink(fromRoomName)+" to "+log_helper_1.LogHelper.roomNameAsLink(toRoomName)),null;const thisRoomsExits=Game.rooms[fromRoomName].find(result1[0].exit);return currentPos.findClosestByPath(thisRoomsExits)}}exports.MovementHelper=MovementHelper},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnQueueController=void 0;exports.SpawnQueueController=class{static queueCreepSpawn(myRoom,priority,name,role){const newCreep={priority:priority,name:name,role:role};if(0!==myRoom.spawnQueue.length){for(let i=0;i<myRoom.spawnQueue.length;i++)if(newCreep.priority>myRoom.spawnQueue[i].priority)return void myRoom.spawnQueue.splice(i,0,newCreep);myRoom.spawnQueue=myRoom.spawnQueue.concat(newCreep)}else myRoom.spawnQueue.push(newCreep)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FlagHelper=void 0;exports.FlagHelper=class{static getFlag1(nameArray,roomName){const flagNames=Object.keys(Game.flags);for(let i=0;i<flagNames.length;i++){const flag=Game.flags[flagNames[i]];if(flag.pos.roomName!==roomName)continue;const flagNameSplit=flag.name.split("-");if(flagNameSplit.length<nameArray.length)continue;let noMatch=!1;for(let j=0;j<nameArray.length;j++)if(flagNameSplit[j]!==nameArray[j]){noMatch=!0;break}if(!noMatch)return flag}return null}static getFlags1(nameArray,roomName){const result=[],flagNames=Object.keys(Game.flags);for(let i=0;i<flagNames.length;i++){const flag=Game.flags[flagNames[i]];if(flag.pos.roomName!==roomName)continue;const flagNameSplit=flag.name.split("-");if(flagNameSplit.length<nameArray.length)continue;let noMatch=!1;for(let j=0;j<nameArray.length;j++)if(flagNameSplit[j]!==nameArray[j]){noMatch=!0;break}noMatch||result.push(flag)}return result}static getFlags2(nameArray,roomName,numberUpToInclusive){const result=[],flagNames=Object.keys(Game.flags);for(let i=0;i<flagNames.length;i++){const flag=Game.flags[flagNames[i]];if(flag.pos.roomName!==roomName)continue;const flagNameSplit=flag.name.split("-");if(flagNameSplit.length<nameArray.length)continue;let j=0,noMatch=!1;for(;j<nameArray.length;j++)if(flagNameSplit[j]!==nameArray[j]){noMatch=!0;break}if(noMatch)continue;Number(flagNameSplit[j])>numberUpToInclusive||result.push(flag)}return result}static getFlags3(nameArray){const result=[],flagNames=Object.keys(Game.flags);for(let i=0;i<flagNames.length;i++){const flag=Game.flags[flagNames[i]],flagNameSplit=flag.name.split("-");if(flagNameSplit.length<nameArray.length)continue;let noMatch=!1;for(let j=0;j<nameArray.length;j++)if(flagNameSplit[j]!==nameArray[j]){noMatch=!0;break}noMatch||result.push(flag)}return result}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnConstants=void 0;class SpawnConstants{}exports.SpawnConstants=SpawnConstants,SpawnConstants.ATTACK_QUICK=5,SpawnConstants.FORCE_LABORER=4.5,SpawnConstants.STOCKER=4.25,SpawnConstants.CLAIMER=4,SpawnConstants.BANK_LINKER=3.5,SpawnConstants.MINER=3,SpawnConstants.DIGGER=2.75,SpawnConstants.DIGGING_HAULER=2.6,SpawnConstants.POWER_BANK_HEAL=2.55,SpawnConstants.POWER_BANK_ATTACK=2.5,SpawnConstants.ATTACK_PRESSURE=2.5,SpawnConstants.SCAVENGER=2.25,SpawnConstants.UPGRADER=2,SpawnConstants.HAULER=2,SpawnConstants.LABORER=1,SpawnConstants.SIGNER=.5},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MapHelper=void 0;const room_helper_1=__webpack_require__(2);class MapHelper{static getRoomDistance(roomOneName,roomTwoName){const result=Game.map.findRoute(roomOneName,roomTwoName,{routeCallback:(room2,room1)=>Memory.myMemory.empire.avoidRooms.includes(room2)?1/0:1});return result===ERR_NO_PATH?1/0:result.length+1}static isMiddle3x3(roomName){const myRoomName=room_helper_1.RoomHelper.getRoomNameAsInterface(roomName),xResult=myRoomName.xNum%10,yResult=myRoomName.yNum%10;return xResult>=4&&xResult<=6&&yResult>=4&&yResult<=6}static isHighway(roomName){const myRoomName=room_helper_1.RoomHelper.getRoomNameAsInterface(roomName),xResult=myRoomName.xNum%10,yResult=myRoomName.yNum%10;return 0===xResult||0===yResult}static findClosestSpawnRoomName(roomPos,minimumStage=1){let result=null,closestDistance=9999;for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myRoom=Memory.myMemory.myRooms[i];if(myRoom.roomStage>=minimumStage){const distance=this.getRoomDistance(roomPos.roomName,myRoom.name);distance<closestDistance&&(closestDistance=distance,result=myRoom.name)}}return result}static findClosestBank(roomName,spareCapacity=-1){let bankToReturn=null,closestDistance=9999;for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myRoom=Memory.myMemory.myRooms[i];if(null!=myRoom.bank&&myRoom.bank.object.store.getFreeCapacity()>spareCapacity){const distance=this.getRoomDistance(roomName,myRoom.name);distance<closestDistance&&(closestDistance=distance,bankToReturn=myRoom.bank.object)}}return bankToReturn}static getClosestRooms(roomPos,minimumStage=1,minimumEnergyInBank=-1){let closestDistance=999,closestRooms=[];for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myRoom=Memory.myMemory.myRooms[i];if(myRoom.roomStage<minimumStage)continue;if(minimumEnergyInBank>=1&&(null==myRoom.bank||null==myRoom.bank.object||myRoom.bank.object.store.energy<minimumEnergyInBank))continue;const roomDistance=MapHelper.getRoomDistance(roomPos.roomName,myRoom.name);roomDistance===closestDistance?closestRooms.push(myRoom.name):roomDistance<closestDistance&&(closestRooms=[myRoom.name],closestDistance=roomDistance)}return closestRooms}}exports.MapHelper=MapHelper},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AttackHelperFunctions=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),log_helper_1=__webpack_require__(1);exports.AttackHelperFunctions=class{static getNewTargetIfNeeded(attackTarget,flagToPathFrom){if(null==flagToPathFrom.room)return null;const attackPrioFlag=Game.flags["attack-prio"];if(null!=attackPrioFlag&&(attackTarget=this.attackPrio(attackPrioFlag)),null!=attackTarget){const roomObject=Game.getObjectById(attackTarget.id);null==roomObject||Game.time%10==0?attackTarget=this.getAttackTarget(flagToPathFrom):attackTarget.roomObject=roomObject}else attackTarget=this.getAttackTarget(flagToPathFrom);return attackTarget}static endAttack(){const flagNames=Object.keys(Game.flags);for(let i=flagNames.length-1;i>=0;i--)if(flagNames[i].includes("attack")){Game.flags[flagNames[i]].remove()}}static getBody(myRoom){const room=Game.rooms[myRoom.name];return creep_helper_1.CreepHelper.generateBody([MOVE,ATTACK],[MOVE,ATTACK],room,!0,50,!0)}static getAttackTarget(flagToPathFrom){const flagPos=flagToPathFrom.pos,room=flagToPathFrom.room,costMatrix=new PathFinder.CostMatrix;room.find(FIND_STRUCTURES).forEach((function(struct){struct.structureType!==STRUCTURE_WALL&&struct.structureType!==STRUCTURE_RAMPART||costMatrix.set(struct.pos.x,struct.pos.y,255)}));const spawns=room.find(FIND_HOSTILE_SPAWNS),spawnTarget=this.pathFindToRoomObject(flagPos,spawns,costMatrix);if(null!=spawnTarget)return report_controller_1.ReportController.log("New Attack Target (Spawn) "+JSON.stringify(spawnTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(spawnTarget.roomObject.pos),{roomObject:spawnTarget.roomObject,id:spawnTarget.roomObject.id,type:"Spawn"};const towers=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TOWER}),towerTarget=this.pathFindToRoomObject(flagPos,towers,costMatrix);if(null!=towerTarget)return report_controller_1.ReportController.log("New Attack Target (Tower) "+JSON.stringify(towerTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(towerTarget.roomObject.pos),{roomObject:towerTarget.roomObject,id:towerTarget.roomObject.id,type:"Tower"};const creeps=room.find(FIND_HOSTILE_CREEPS),creepTarget=this.pathFindToRoomObject(flagPos,creeps,costMatrix);if(null!=creepTarget)return report_controller_1.ReportController.log("New Attack Target (Creep) "+JSON.stringify(creepTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(creepTarget.roomObject.pos),{roomObject:creepTarget.roomObject,id:creepTarget.roomObject.id,type:"Creep"};const extensions=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_EXTENSION}),extensionTarget=this.pathFindToRoomObject(flagPos,extensions,costMatrix);if(null!=extensionTarget)return report_controller_1.ReportController.log("New Attack Target (Extension) "+JSON.stringify(extensionTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(extensionTarget.roomObject.pos),{roomObject:extensionTarget.roomObject,id:extensionTarget.roomObject.id,type:"Extension"};const ramparts=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_RAMPART}),rampartTarget=this.pathFindToRoomObject(flagPos,ramparts,costMatrix);if(null!=rampartTarget)return report_controller_1.ReportController.log("New Attack Target (Rampart) "+JSON.stringify(rampartTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(rampartTarget.roomObject.pos),{roomObject:rampartTarget.roomObject,id:rampartTarget.roomObject.id,type:"Rampart"};const walls=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_WALL}),wallTarget=this.pathFindToRoomObject(flagPos,walls,costMatrix);return null!=wallTarget?(report_controller_1.ReportController.log("New Attack Target (Wall) "+JSON.stringify(wallTarget.roomObject.pos)),log_helper_1.LogHelper.markTarget(wallTarget.roomObject.pos),{roomObject:wallTarget.roomObject,id:wallTarget.roomObject.id,type:"Wall"}):null}static pathFindToRoomObject(start,roomObjects,costmatrix){if(0===roomObjects.length)return null;let result=null;for(let i=0;i<roomObjects.length;i++){const roomObject=roomObjects[i],pathFinderPath=PathFinder.search(start,{pos:roomObject.pos,range:1},{roomCallback:roomName=>{if(roomName===start.roomName)return costmatrix;{const room=Game.rooms[roomName],costMatrix=new PathFinder.CostMatrix;return null==room||room.find(FIND_STRUCTURES).forEach((function(struct){struct.structureType!==STRUCTURE_WALL&&struct.structureType!==STRUCTURE_RAMPART||costMatrix.set(struct.pos.x,struct.pos.y,255)})),costMatrix}}});pathFinderPath.incomplete||(null==result||result.pathFinderPath.cost>pathFinderPath.cost)&&(result={roomObject:roomObject,pathFinderPath:pathFinderPath})}return result}static attackPrio(attackPrioFlag){const structures=attackPrioFlag.pos.lookFor(LOOK_STRUCTURES);if(log_helper_1.LogHelper.markTarget(attackPrioFlag.pos),attackPrioFlag.remove(),0===structures.length)return null;let structureType=structures[0].structureType;return"constructedWall"===structureType&&(structureType="Wall"),{roomObject:structures[0],id:structures[0].id,type:structureType}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ScavengeController=void 0;const constants_1=__webpack_require__(4),map_helper_1=__webpack_require__(11),spawn_queue_controller_1=__webpack_require__(8),creep_helper_1=__webpack_require__(3),spawn_constants_1=__webpack_require__(10),report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.ScavengeController=class{static run(myMemory){if(Game.time%10!=0)return;const flagNames=Object.keys(Game.flags);for(let i=flagNames.length-1;i>=0;i--){"scavenge"!==flagNames[i].split("-")[0]&&flagNames.splice(i,1)}if(1!==flagNames.length)return;const flag=Game.flags[flagNames[0]],amountOfResources=Number(flag.name.split("-")[1]);this.startScavenge(flag.pos.roomName,amountOfResources,myMemory,!0),flag.remove()}static generateTickQuoteForPowerBanks(roomName,amountOfResources){const myRooms=this.generateRoomListForScavengerSpawning(roomName,amountOfResources,Memory.myMemory,!1);if(0===myRooms.length)return report_controller_1.ReportController.email("ERROR: generateTickQuoteForPowerBanks gave 0 rooms"),-1;const amountOfRoomsNeeded=Math.ceil(amountOfResources/1250);return 150+50*myRooms[Math.min(myRooms.length-1,amountOfRoomsNeeded-1)].roomDistance}static startScavenge(roomName,amountOfResources,myMemory,allowReturnTrips){const myRooms=this.generateRoomListForScavengerSpawning(roomName,amountOfResources,myMemory,allowReturnTrips);if(0===myRooms.length)return;const amountOfCarryPartsNeeded=Math.ceil(amountOfResources/50);let amountOfCarryPartsQueued=0,amountOfCreepsSpawned=0,roomIndex=0,spawnedFromString="",loopedThroughOnce=!1;do{const scavengeMyRoom=myRooms[roomIndex];this.spawnScavengeCreep(scavengeMyRoom,roomName,myMemory),amountOfCarryPartsQueued+=scavengeMyRoom.amountOfCarryPerCreep,amountOfCreepsSpawned++,roomIndex++,loopedThroughOnce||(spawnedFromString+=log_helper_1.LogHelper.roomNameAsLink(scavengeMyRoom.myRoom.name)+" "),roomIndex===myRooms.length&&(roomIndex=0,loopedThroughOnce=!0)}while(amountOfCarryPartsQueued<amountOfCarryPartsNeeded);report_controller_1.ReportController.log("Scavenging: Spawned from rooms: "+spawnedFromString),report_controller_1.ReportController.log("Scavenging: Spawned "+amountOfCreepsSpawned+" creeps across (up to) "+myRooms.length+" rooms for scavenging "+log_helper_1.LogHelper.roomNameAsLink(roomName))}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,CARRY],[MOVE,CARRY],Game.rooms[myRoom.name],!0)}static spawnScavengeCreep(scavengeMyRoom,scavengingRoomName,myMemory){const name=creep_helper_1.CreepHelper.getName();spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(scavengeMyRoom.myRoom,spawn_constants_1.SpawnConstants.SCAVENGER,name,"Scavenger"),myMemory.empire.creeps.push({name:name,role:"Scavenger",assignedRoomName:scavengingRoomName,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},state:"Scavenging",scavengingRoomName:scavengingRoomName,scavengeAgainWhenTtlAbove:scavengeMyRoom.scavengeAgainWhenTtlAbove,scavengeTargetPos:null})}static generateRoomListForScavengerSpawning(roomName,amountOfResources,myMemory,allowReturnTrips){const myRooms=[],closestBank=map_helper_1.MapHelper.findClosestBank(roomName,amountOfResources);if(null==closestBank)return report_controller_1.ReportController.email("ERROR: closestBank is null while trying to scavenge"),[];const distanceToBank=map_helper_1.MapHelper.getRoomDistance(roomName,closestBank.room.name);for(let i=0;i<myMemory.myRooms.length;i++){const myRoom=myMemory.myRooms[i];if(myRoom.roomStage<constants_1.Constants.SCAVENGE_MIN_STAGE)continue;const spawnToScavengeRoom=map_helper_1.MapHelper.getRoomDistance(roomName,myRoom.name);if(map_helper_1.MapHelper.getRoomDistance(roomName,myRoom.name)>constants_1.Constants.SCAVENGE_MAX_DISTANCE)continue;const oneWayTripToBank=50*distanceToBank,ttlAfterFirstTrip=1500-50*spawnToScavengeRoom-oneWayTripToBank;if(ttlAfterFirstTrip<0)continue;const amountOfTripsOneCreepCanDo=1+Math.floor(ttlAfterFirstTrip/(2*oneWayTripToBank));let scavengeAgainWhenTtlAbove,repeatedCarryPerCreep;allowReturnTrips?(scavengeAgainWhenTtlAbove=2*oneWayTripToBank,repeatedCarryPerCreep=amountOfTripsOneCreepCanDo*constants_1.Constants.SCAVENGE_CARRY_PER_CREEP):(scavengeAgainWhenTtlAbove=1501,repeatedCarryPerCreep=constants_1.Constants.SCAVENGE_CARRY_PER_CREEP),myRooms.push({amountOfCarryPerCreep:repeatedCarryPerCreep,myRoom:myRoom,scavengeAgainWhenTtlAbove:scavengeAgainWhenTtlAbove,roomDistance:spawnToScavengeRoom})}return myRooms.sort((a,b)=>a.roomDistance-b.roomDistance),myRooms}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PowerBankController=void 0;const constants_1=__webpack_require__(4),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),report_controller_1=__webpack_require__(0),map_helper_1=__webpack_require__(11),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),creep_helper_1=__webpack_require__(3),power_bank_attack_creep_1=__webpack_require__(62),power_bank_heal_creep_1=__webpack_require__(85),scavenge_controller_1=__webpack_require__(13);exports.PowerBankController=class{static observedPowerBank(powerBank){const powerBankTargets=Memory.myMemory.empire.powerBanks;if(powerBank.ticksToDecay<constants_1.Constants.POWER_BANK_TTL_MIN)return;if(powerBankTargets.targetBanks.length>=constants_1.Constants.POWER_BANK_MAX_BANKS_AT_ONE_TIME)return;for(let i=0;i<powerBankTargets.targetBanks.length;i++){if(powerBankTargets.targetBanks[i].id===powerBank.id)return}const closestRoomNames=map_helper_1.MapHelper.getClosestRooms(powerBank.pos,constants_1.Constants.POWER_BANK_ROOM_STAGE,constants_1.Constants.POWER_BANK_MIN_ENERGY);if(0===closestRoomNames.length)return;const closestDistance=map_helper_1.MapHelper.getRoomDistance(closestRoomNames[0],powerBank.pos.roomName);if(closestDistance>constants_1.Constants.POWER_BANK_RANGE_MAX)return;const amountOfPositionsAroundBank=room_helper_1.RoomHelper.areaAroundPos(powerBank.pos,powerBank.room);if(amountOfPositionsAroundBank<constants_1.Constants.POWER_BANK_AREA_AROUND_BANK_MIN)return;if(powerBank.power<constants_1.Constants.POWER_BANK_MIN_POWER)return;const storage=map_helper_1.MapHelper.findClosestBank(powerBank.room.name);if(null==storage||storage.store.power>constants_1.Constants.POWER_BANK_CLOSEST_STORAGE_POWER_BELOW)return;if(powerBank.room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_WALL}).length>0)return;const roomsToSpawnThrough=[];for(let i=0;i<closestRoomNames.length;i++)roomsToSpawnThrough.push(closestRoomNames[i]);const damageDonePerCreep=(1500-closestDistance*powerBankTargets.averageDuoTravelTicksPerRoom)*constants_1.Constants.POWER_BANK_MAX_DAMAGE_PER_TICK_PER_AREA,creepsDuosStillNeeded=Math.ceil(2e6/damageDonePerCreep),scavengeTicksQuote=scavenge_controller_1.ScavengeController.generateTickQuoteForPowerBanks(powerBank.room.name,powerBank.power);powerBankTargets.targetBanks.push({id:powerBank.id,pos:room_helper_1.RoomHelper.roomPosToMyPos(powerBank.pos),roomsToGetCreepsFrom:roomsToSpawnThrough,roomsToGetCreepsFromIndex:0,eol:Game.time+powerBank.ticksToDecay,roomDistanceToBank:closestDistance,creeps:[],creepsDuosStillNeeded:creepsDuosStillNeeded,amountOfPositionsAroundBank:amountOfPositionsAroundBank,power:powerBank.power,queuedHaulers:!1,scavengeTicksQuote:scavengeTicksQuote})}static run(powerBankTargets){for(let i=powerBankTargets.targetBanks.length-1;i>=0;i--){const powerBankTarget=powerBankTargets.targetBanks[i];if(Game.time>powerBankTarget.eol)powerBankTargets.targetBanks.splice(i,1),report_controller_1.ReportController.log("BAD: Power Bank died from EOL in "+log_helper_1.LogHelper.roomNameAsLink(powerBankTarget.pos.roomName));else if(0===powerBankTarget.creepsDuosStillNeeded&&0===powerBankTarget.creeps.length){powerBankTargets.targetBanks.splice(i,1);null==Game.getObjectById(powerBankTarget.id)?report_controller_1.ReportController.log("Power Bank killed in "+log_helper_1.LogHelper.roomNameAsLink(powerBankTarget.pos.roomName)):report_controller_1.ReportController.log("BAD: Power Bank attack failed, all creeps dead, bank alive in "+log_helper_1.LogHelper.roomNameAsLink(powerBankTarget.pos.roomName))}else this.handleBank(powerBankTarget,powerBankTargets)}}static getAttackerBody(){return[MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK]}static getHealerBody(){return[MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL,HEAL]}static handleBank(powerBankTarget,powerBankTargets){for(let i=powerBankTarget.creeps.length-1;i>=0;i--){const creepDuo=powerBankTarget.creeps[i];null!=creepDuo.attack&&"alive"===creepDuo.attack.spawningStatus&&null==Game.creeps[creepDuo.attack.name]&&(creepDuo.attack=null),null!=creepDuo.heal&&"alive"===creepDuo.heal.spawningStatus&&null==Game.creeps[creepDuo.heal.name]&&(creepDuo.heal=null),null==creepDuo.heal&&null==creepDuo.attack&&(report_controller_1.ReportController.log("Power Bank duo died for bank "+log_helper_1.LogHelper.roomNameAsLink(powerBankTarget.pos.roomName)),powerBankTarget.creeps.splice(i,1))}this.trySpawnCreepDuoIfNeeded(powerBankTarget,powerBankTargets);const powerBank=Game.getObjectById(powerBankTarget.id);if(null!=powerBank&&!powerBankTarget.queuedHaulers&&Game.time%10==0){const damagePerTick=powerBankTarget.creeps.length*constants_1.Constants.POWER_BANK_MAX_DAMAGE_PER_TICK_PER_AREA;if(powerBank.hits/damagePerTick<powerBankTarget.scavengeTicksQuote){let damageInQuoteTime=0;for(let i=0;i<powerBankTarget.creeps.length;i++){const creepDuo=powerBankTarget.creeps[i];if(creepDuo.averagesAdded){let maxDamageTicks;maxDamageTicks=null==creepDuo.heal||null==creepDuo.attack?0:Math.min(powerBankTarget.scavengeTicksQuote,Game.creeps[creepDuo.attack.name].ticksToLive,Game.creeps[creepDuo.heal.name].ticksToLive),damageInQuoteTime+=maxDamageTicks*constants_1.Constants.POWER_BANK_MAX_DAMAGE_PER_TICK_PER_AREA}}damageInQuoteTime>powerBank.hits&&(powerBankTarget.queuedHaulers=!0,scavenge_controller_1.ScavengeController.startScavenge(powerBank.room.name,powerBankTarget.power,Memory.myMemory,!1))}}for(let i=0;i<powerBankTarget.creeps.length;i++)this.runCreepDuo(powerBankTarget.creeps[i],powerBankTarget,powerBank,powerBankTargets)}static runCreepDuo(creepDuo,powerBankTarget,powerBank,powerBankTargets){if(null!=creepDuo.attack&&power_bank_attack_creep_1.RolePowerBankAttackCreep.run(creepDuo.attack,powerBankTarget,powerBank,creepDuo.heal),null!=creepDuo.heal&&power_bank_heal_creep_1.RolePowerBankHealCreep.run(creepDuo.heal,powerBankTarget,powerBank,creepDuo.attack),!creepDuo.averagesAdded&&null!=creepDuo.attack&&creepDuo.attack.reachedPowerBank&&null!=creepDuo.heal&&creepDuo.heal.reachedPowerBank){const newValue=(1500-Math.max(Game.creeps[creepDuo.attack.name].ticksToLive,Game.creeps[creepDuo.heal.name].ticksToLive))/powerBankTarget.roomDistanceToBank;powerBankTargets.averageDuoTravelTicksPerRoom=(powerBankTargets.averageDuoTravelTicksPerRoom*powerBankTargets.countDuoTravelTicksPerRoom+newValue)/(powerBankTargets.countDuoTravelTicksPerRoom+1),powerBankTargets.countDuoTravelTicksPerRoom+=1,creepDuo.averagesAdded=!0}}static trySpawnCreepDuoIfNeeded(bank,powerBankTargets){if(bank.creepsDuosStillNeeded<=0)return;let creepDuosStillGood=0,creepDuoToReplaceIndex=-1;for(let i=0;i<bank.creeps.length;i++){const creepDuo=bank.creeps[i];if(!bank.creeps[i].beenReplaced&&Game.time>=creepDuo.replaceAtTick){creepDuoToReplaceIndex=i;break}creepDuosStillGood++}if(!(creepDuosStillGood<bank.amountOfPositionsAroundBank||creepDuoToReplaceIndex>=0))return;bank.roomsToGetCreepsFromIndex++,bank.roomsToGetCreepsFromIndex>=bank.roomsToGetCreepsFrom.length&&(bank.roomsToGetCreepsFromIndex=0);const roomName=bank.roomsToGetCreepsFrom[bank.roomsToGetCreepsFromIndex],myRoom=room_helper_1.RoomHelper.getMyRoomByName(roomName);if(null==myRoom)return;for(let i=0;myRoom.spawnQueue.length;i++){const queuedCreep=myRoom.spawnQueue[i];if("PowerBankAttackCreep"===queuedCreep.role||"PowerBankHealCreep"===queuedCreep.role)return void bank.roomsToGetCreepsFromIndex--}const newHealCreep=this.spawnHealCreep(bank,myRoom),newAttackCreep=this.spawnAttackCreep(bank,myRoom),maxTravelTime=powerBankTargets.averageDuoTravelTicksPerRoom*bank.roomDistanceToBank,newCreepDuo={attack:newAttackCreep,heal:newHealCreep,beenReplaced:!1,replaceAtTick:Game.time+1500-maxTravelTime-constants_1.Constants.POWER_BANK_DUO_TICKS_TO_SPAWN,averagesAdded:!1};bank.creeps.push(newCreepDuo),report_controller_1.ReportController.log("Queued a new Power Bank Creep Duo in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" for power bank in "+log_helper_1.LogHelper.roomNameAsLink(bank.pos.roomName)),bank.creepsDuosStillNeeded--,-1!==creepDuoToReplaceIndex&&(report_controller_1.ReportController.log("Duo just queued was a replacement team"),bank.creeps[creepDuoToReplaceIndex].beenReplaced=!0)}static spawnAttackCreep(powerBankDetails,myRoom){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.POWER_BANK_ATTACK,name,"PowerBankAttackCreep"),{name:name,role:"PowerBankAttackCreep",assignedRoomName:powerBankDetails.pos.roomName,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},reachedPowerBank:!1}}static spawnHealCreep(powerBankDetails,myRoom){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.POWER_BANK_HEAL,name,"PowerBankHealCreep"),{name:name,role:"PowerBankHealCreep",assignedRoomName:powerBankDetails.pos.roomName,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},reachedPowerBank:!1}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EmpireHelper=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.EmpireHelper=class{static isAllyUsername(username){return-1!==["james1652"].indexOf(username.toLowerCase())}static getValidResourceTransfer(empire,roomName){let result=null;for(let i=0;i<empire.transfers.length;i++){const transfer=empire.transfers[i];if(transfer.roomFrom===roomName){if("Loading"===transfer.state||"Sending"===transfer.state)if(null==result)result=transfer;else if(transfer.actionStarted){result=transfer;break}}else if(transfer.roomTo===roomName&&"Unloading"===transfer.state)if(0===transfer.amountLeft)report_controller_1.ReportController.log("Unloaded "+transfer.amount+" "+transfer.resource+" from "+log_helper_1.LogHelper.roomNameAsLink(transfer.roomFrom)+" to "+log_helper_1.LogHelper.roomNameAsLink(transfer.roomTo)),empire.transfers.splice(i,1),i--,0===empire.transfers.length&&report_controller_1.ReportController.log("No more transfers");else if(null==result)result=transfer;else if(transfer.actionStarted){result=transfer;break}}if(null==result)return null;if(result.actionStarted=!0,result.roomFrom===roomName)if("Loading"===result.state){if(0===result.amountLeft){const terminals=Game.rooms[roomName].find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TERMINAL});if(1===terminals.length){const terminal=terminals[0];if(terminal.store.getUsedCapacity(result.resource)>=result.amount){terminal.send(result.resource,result.amount,result.roomTo)===OK&&(report_controller_1.ReportController.log("Sending "+result.amount+" "+result.resource+" from "+log_helper_1.LogHelper.roomNameAsLink(result.roomFrom)+" to "+log_helper_1.LogHelper.roomNameAsLink(result.roomTo)),result.state="Sending",result.amountLeft=result.amount)}}return null}}else if("Sending"===result.state)return report_controller_1.ReportController.log("Unloading "+result.amount+" "+result.resource+" from "+log_helper_1.LogHelper.roomNameAsLink(result.roomFrom)+" to "+log_helper_1.LogHelper.roomNameAsLink(result.roomTo)),result.state="Unloading",result.actionStarted=!1,null;return result}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MemoryController=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2);exports.MemoryController=class{static run(){this.clearDeadCreeps(),this.ensureAllRoomsInMyMemory(),this.validateRoomsInMyMemory(),this.cleanUpEmpireCreeps(),this.getBanks(),this.cleanupReportMap()}static clearDeadCreeps(){for(const i in Memory.creeps)Game.creeps[i]||delete Memory.creeps[i]}static ensureAllRoomsInMyMemory(){for(const roomName in Game.rooms){const room=Game.rooms[roomName];let myRoom=null;if(null!=room.controller&&!0===room.controller.my){for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myExistingRoom=Memory.myMemory.myRooms[i];null!=myExistingRoom&&myExistingRoom.name===roomName&&(myRoom=myExistingRoom)}if(null==myRoom){report_controller_1.ReportController.log("Adding a new room to memory "+log_helper_1.LogHelper.roomNameAsLink(roomName));const minerals=room.find(FIND_MINERALS);if(1!==minerals.length)return void report_controller_1.ReportController.email("ERROR: Room didn't have a mineral");const newMyRoom={name:roomName,myCreeps:[],mySources:[],roomStage:-1,bank:null,spawnQueue:[],rampartsUp:!0,controllerLink:null,labs:null,nukerStatus:null,powerSpawn:null,digging:{active:!1,mineral:minerals[0].mineralType,mineralId:minerals[0].id,cache:null,diggerName:null,haulerName:null}},sources=room.find(FIND_SOURCES);for(let i=0;i<sources.length;i++){const source=sources[i];newMyRoom.mySources.push({id:source.id,state:"NoCache",minerName:null,haulerName:null,cache:null,link:null})}Memory.myMemory.myRooms.push(newMyRoom)}}}}static validateRoomsInMyMemory(){for(let i=Memory.myMemory.myRooms.length-1;i>=0;i--){const myRoom=Memory.myMemory.myRooms[i],room=Game.rooms[myRoom.name];if(null!=room&&null!=room.controller&&!1!==room.controller.my)for(let j=myRoom.myCreeps.length-1;j>=0;j--){const myCreep=myRoom.myCreeps[j];null==Game.creeps[myCreep.name]&&"queued"!==myCreep.spawningStatus&&(this.handleCreepDying(myRoom,myCreep),myRoom.myCreeps.splice(j,1))}else report_controller_1.ReportController.log("Removing room from memory "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),Memory.myMemory.myRooms.splice(i,1)}}static handleCreepDying(myRoom,myCreep){if("Miner"===myCreep.role)for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];mySource.minerName===myCreep.name&&(mySource.minerName=null)}else if("Hauler"===myCreep.role){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(mySource.haulerName===myCreep.name)return void(mySource.haulerName=null)}myRoom.digging.haulerName===myCreep.name&&(myRoom.digging.haulerName=null)}else"Laborer"===myCreep.role||"Claimer"===myCreep.role||("BankLinker"===myCreep.role?myRoom.bank.bankLinkerName=null:"Stocker"===myCreep.role||("Digger"===myCreep.role?myRoom.digging.diggerName=null:"Upgrader"===myCreep.role||report_controller_1.ReportController.email("ERROR: A Creep with a weird role has died: "+myCreep.role+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))))}static cleanUpEmpireCreeps(){for(let i=Memory.myMemory.empire.creeps.length-1;i>=0;i--){const myCreep=Memory.myMemory.empire.creeps[i];null==Game.creeps[myCreep.name]&&"queued"!==myCreep.spawningStatus&&Memory.myMemory.empire.creeps.splice(i,1)}}static getBanks(){for(let i=0;i<Memory.myMemory.myRooms.length;i++){const myRoom=Memory.myMemory.myRooms[i];if(null!=myRoom.bank){const structures=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos).lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_STORAGE){myRoom.bank.object=structures[j];break}}}}static cleanupReportMap(){if(Game.time%100!=0)return;const myMemory=Memory.myMemory,reports=Object.keys(myMemory.reports),now=(new Date).getTime();for(let i=0;i<reports.length;i++)Memory.myMemory.reports[reports[i]]<now&&delete Memory.myMemory.reports[reports[i]]}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnClaimerController=void 0;const report_controller_1=__webpack_require__(0),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),room_helper_1=__webpack_require__(2),creep_helper_1=__webpack_require__(3),log_helper_1=__webpack_require__(1),map_helper_1=__webpack_require__(11);exports.SpawnClaimerController=class{static run(myMemory){if(Game.time%10!=0)return;const flag=Game.flags.claim;if(null!=flag)if(null!=flag.room&&null!=flag.room.controller&&!0===flag.room.controller.my)flag.remove(),report_controller_1.ReportController.log("Room "+log_helper_1.LogHelper.roomNameAsLink(flag.room.name)+" has been claimed");else{let claimerAlreadyMade=!1;for(let j=0;j<myMemory.empire.creeps.length;j++){if("Claimer"===myMemory.empire.creeps[j].role){claimerAlreadyMade=!0;break}}if(!claimerAlreadyMade){const claimer=this.spawnClaimer(flag);null!=claimer&&myMemory.empire.creeps.push(claimer)}}}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,CLAIM],[MOVE],Game.rooms[myRoom.name],!0,6)}static spawnClaimer(flag){const roomToSpawnFromName=map_helper_1.MapHelper.findClosestSpawnRoomName(flag.pos,3);if(null==roomToSpawnFromName)return flag.remove(),report_controller_1.ReportController.email("ERROR: Couldn't find a spawn to make a claimer for "+log_helper_1.LogHelper.roomNameAsLink(flag.pos.roomName)),null;const roomToSpawnFrom=room_helper_1.RoomHelper.getMyRoomByName(roomToSpawnFromName),name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(roomToSpawnFrom,spawn_constants_1.SpawnConstants.CLAIMER,name,"Claimer"),report_controller_1.ReportController.log("Queued a new claimer in "+log_helper_1.LogHelper.roomNameAsLink(roomToSpawnFrom.name)+" for "+log_helper_1.LogHelper.roomNameAsLink(flag.pos.roomName)),{name:name,role:"Claimer",assignedRoomName:flag.pos.roomName,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},flagName:flag.name}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleAttackCreep=void 0;const constants_1=__webpack_require__(4),movement_helper_1=__webpack_require__(7),creep_helper_1=__webpack_require__(3);exports.RoleAttackCreep=class{static run(attackCreep,attackState,rallyOrRoomTargetFlag,attackTarget){if(creep_helper_1.CreepHelper.handleCreepPreRole(attackCreep))return;const creep=Game.creeps[attackCreep.name];"Rally"===attackState||"Conscripting"===attackState?(movement_helper_1.MovementHelper.myMoveTo(creep,rallyOrRoomTargetFlag.pos,attackCreep),creep.pos.inRangeTo(rallyOrRoomTargetFlag.pos,constants_1.Constants.RALLY_FLAG_RANGE)||creep.say("Moving")):"Charge"===attackState&&this.attackLogic(creep,attackTarget,attackCreep,rallyOrRoomTargetFlag)}static attackLogic(creep,attackTarget,attackCreep,roomTargetFlag){null==attackTarget?(creep.say("No target!"),movement_helper_1.MovementHelper.myMoveTo(creep,roomTargetFlag.pos,attackCreep)):(creep.say(""+attackTarget.type),creep.pos.inRangeTo(attackTarget.roomObject.pos,1)?creep.attack(attackTarget.roomObject):movement_helper_1.MovementHelper.myMoveTo(creep,attackTarget.roomObject.pos,attackCreep))}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomController=void 0;const tower_1=__webpack_require__(20),miner_1=__webpack_require__(21),hauler_1=__webpack_require__(22),room_stage_controller_1=__webpack_require__(23),laborer_1=__webpack_require__(55),room_spawn_controller_1=__webpack_require__(56),bank_linker_1=__webpack_require__(63),link_1=__webpack_require__(64),report_controller_1=__webpack_require__(0),stocker_1=__webpack_require__(65),log_helper_1=__webpack_require__(1),room_defense_controller_1=__webpack_require__(67),digger_1=__webpack_require__(86),lab_1=__webpack_require__(66),nuker_1=__webpack_require__(68),upgrader_1=__webpack_require__(87),power_spawn_1=__webpack_require__(88);exports.RoomController=class{static run(myRoom,transfer){if(null==Game.rooms[myRoom.name])return void report_controller_1.ReportController.email("ERROR: No longer have vision of room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const room=Game.rooms[myRoom.name];room_stage_controller_1.RoomStageController.run(myRoom,room),room_spawn_controller_1.RoomSpawnController.run(myRoom,room),tower_1.RoomTowerController.run(myRoom,room),room_defense_controller_1.RoomDefenseController.run(myRoom,room),nuker_1.RoomNukerController.run(myRoom,room),power_spawn_1.RoomPowerSpawnController.run(myRoom,room);const laborersStock=this.shouldLaborersStock(myRoom),bankLinkerShouldStockLink=link_1.RoomLinkController.run(myRoom),labOrder=lab_1.RoomLabController.run(myRoom);for(let i=0;i<myRoom.myCreeps.length;i++){const myCreep=myRoom.myCreeps[i];"Miner"===myCreep.role?miner_1.RoleMiner.run(myCreep,myRoom):"BankLinker"===myCreep.role?bank_linker_1.RoleBankLinker.run(myCreep,myRoom,transfer,bankLinkerShouldStockLink):"Stocker"===myCreep.role?stocker_1.RoleStocker.run(myCreep,myRoom,labOrder):"Laborer"===myCreep.role?laborer_1.RoleLaborer.run(myCreep,myRoom,laborersStock):"Upgrader"===myCreep.role?upgrader_1.RoleUpgrader.run(myCreep,myRoom):"Digger"===myCreep.role?digger_1.RoleDigger.run(myCreep,myRoom):"Hauler"===myCreep.role&&hauler_1.RoleHauler.run(myCreep,myRoom)}null!=myRoom.bank&&(myRoom.bank.object=null)}static shouldLaborersStock(myRoom){if(myRoom.roomStage<4)return!0;if(Game.rooms[myRoom.name].energyAvailable>600)return!1;if(myRoom.bank.object.store.energy>=1250)return!1;let foundMinerWhosAlive=!1,foundStockerWhosAlive=!1;for(let j=0;j<myRoom.myCreeps.length;j++){const myCreep=myRoom.myCreeps[j];"Miner"===myCreep.role&&"queued"!==myCreep.spawningStatus&&(foundMinerWhosAlive=!0),"Stocker"===myCreep.role&&"queued"!==myCreep.spawningStatus&&(foundStockerWhosAlive=!0)}return!foundStockerWhosAlive||!foundMinerWhosAlive}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomTowerController=void 0;const log_helper_1=__webpack_require__(1),constants_1=__webpack_require__(4),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),empire_helper_1=__webpack_require__(15),creep_helper_1=__webpack_require__(3),flag_helper_1=__webpack_require__(9);exports.RoomTowerController=class{static run(myRoom,room){const towers=room.find(FIND_STRUCTURES,{filter:{structureType:STRUCTURE_TOWER,my:!0}});if(0===towers.length)return;const otherCreeps=this.findOtherCreeps(room);if(this.handleRamparts(myRoom,room,otherCreeps),otherCreeps.hostileCreeps.length>0&&null==room.controller.safeMode&&(!otherCreeps.healers||null!=flag_helper_1.FlagHelper.getFlag1(["tower","aggressive"],room.name))){const target=this.getBestCreepTarget(otherCreeps.hostileCreeps,room.name,towers[0].pos);"Invader"!==target.owner.username&&creep_helper_1.CreepHelper.creepContainsBodyParts(target,[HEAL,CLAIM,ATTACK,RANGED_ATTACK])&&report_controller_1.ReportController.email("Tower attacking target with name "+target.name+" Owner: "+target.owner.username+" in "+log_helper_1.LogHelper.roomNameAsLink(room.name),report_cooldown_constants_1.ReportCooldownConstants.FIVE_MINUTE);for(let i=0;i<towers.length;i++)this.attackIfEnoughEnergy(towers[i],target)}else{const oddThousand=Memory.myMemory.empire.oddThousand,damagedStructures=room.find(FIND_STRUCTURES,{filter:structure=>structure.hits!==structure.hitsMax&&(structure.structureType===STRUCTURE_WALL?constants_1.Constants.REPAIR_ONLY_ON_ODD_THOUSAND?!(!oddThousand&&!otherCreeps.healers)&&structure.hits<constants_1.Constants.WALL_AND_RAMPART_GOAL_HEALTH:structure.hits<constants_1.Constants.WALL_AND_RAMPART_GOAL_HEALTH:structure.structureType===STRUCTURE_RAMPART?constants_1.Constants.REPAIR_ONLY_ON_ODD_THOUSAND?!!(structure.hits<5e3||otherCreeps.healers)||!!(oddThousand&&structure.hits<constants_1.Constants.WALL_AND_RAMPART_GOAL_HEALTH):structure.hits<constants_1.Constants.WALL_AND_RAMPART_GOAL_HEALTH:!otherCreeps.healers)});if(0!==damagedStructures.length){let lowestStructure=damagedStructures[0],lowestStructureHealth=lowestStructure.hits;for(let i=0;i<damagedStructures.length;i++)(damagedStructures[i].hits<lowestStructureHealth||damagedStructures[i].hits===lowestStructureHealth&&damagedStructures[i].structureType!==STRUCTURE_WALL)&&(lowestStructure=damagedStructures[i],lowestStructureHealth=lowestStructure.hits);if(constants_1.Constants.REPAIR_ONLY_ON_ODD_THOUSAND&&0===otherCreeps.hostileCreeps.length&&!oddThousand&&(lowestStructure.structureType!==STRUCTURE_RAMPART||lowestStructure.hits>5e3))return;if(null!=flag_helper_1.FlagHelper.getFlag1(["tower","no","repair"],room.name))return;const minimumEnergyToRepair=0===otherCreeps.hostileCreeps.length?500:10;for(let i=0;i<towers.length&&(!this.repairIfEnoughEnergy(towers[i],lowestStructure,minimumEnergyToRepair)||0!==otherCreeps.hostileCreeps.length);i++);}}}static repairIfEnoughEnergy(tower,structure,minimumEnergyToRepair){return tower.store.energy>=minimumEnergyToRepair&&(tower.repair(structure),!0)}static attackIfEnoughEnergy(tower,target){tower.attack(target)}static getBestCreepTarget(hostileCreeps,roomName,roomPosition){if(0===hostileCreeps.length)return hostileCreeps[0];let towerAlgorithm="Healer";flag_helper_1.FlagHelper.getFlag1(["tower","closest"],roomName)&&(towerAlgorithm="Closest");let target=null,closestDistance=50;for(let i=0;i<hostileCreeps.length;i++){const hostileCreep=hostileCreeps[i];let isHealer=!1;for(let j=0;j<hostileCreep.body.length;j++){if(hostileCreep.body[j].type===HEAL){isHealer=!0;break}}const distance=roomPosition.getRangeTo(hostileCreep);if("Healer"===towerAlgorithm&&isHealer){target=hostileCreep;break}"Closest"===towerAlgorithm&&distance<closestDistance?(closestDistance=distance,target=hostileCreep):null==target&&(target=hostileCreep)}return target}static findOtherCreeps(room){const result={hostileCreeps:[],alliedCreeps:[],healers:!1},otherCreeps=room.find(FIND_HOSTILE_CREEPS);for(let i=0;i<otherCreeps.length;i++){const possibleHostileCreep=otherCreeps[i];empire_helper_1.EmpireHelper.isAllyUsername(possibleHostileCreep.owner.username)?result.alliedCreeps.push(possibleHostileCreep):(result.hostileCreeps.push(possibleHostileCreep),result.healers||creep_helper_1.CreepHelper.creepContainsBodyPart(possibleHostileCreep,HEAL)&&(result.healers=!0))}return result}static handleRamparts(myRoom,room,findOtherCreepsResult){myRoom.rampartsUp?findOtherCreepsResult.alliedCreeps.length>0&&0===findOtherCreepsResult.hostileCreeps.length&&(report_controller_1.ReportController.email("Putting ramparts DOWN in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),this.setRampartStatus(myRoom,room,!1)):(0===findOtherCreepsResult.alliedCreeps.length||findOtherCreepsResult.hostileCreeps.length>0)&&(this.setRampartStatus(myRoom,room,!0),report_controller_1.ReportController.email("Putting ramparts UP in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)))}static setRampartStatus(myRoom,room,up){const ramparts=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_RAMPART});for(let i=0;i<ramparts.length;i++)ramparts[i].setPublic(!up);myRoom.rampartsUp=up}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleMiner=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7);exports.RoleMiner=class{static run(miner,myRoom){if(creep_helper_1.CreepHelper.handleCreepPreRole(miner))return;const creep=Game.creeps[miner.name],cachePos=room_helper_1.RoomHelper.myPosToRoomPos(miner.cachePosToMineOn);if(cachePos.isEqualTo(creep.pos)){const source=Game.getObjectById(miner.sourceId);if(null==source)return void report_controller_1.ReportController.email("ERROR: Miner has been given a source which is null. Creep ID: "+miner.name+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));if(source.energy>0&&(0===creep.store.energy||creep.store.energy<=creep.store.getCapacity()-2*miner.amountOfWork||0===creep.store.getCapacity())){let mySource=null;for(let i=0;i<myRoom.mySources.length;i++)myRoom.mySources[i].minerName===miner.name&&(mySource=myRoom.mySources[i]);if("Cache"!==mySource.state)creep.harvest(source);else if(null!=mySource.cache&&null!=mySource.cache.id){const cache=Game.getObjectById(mySource.cache.id);null!=cache?cache.store.energy<2e3&&creep.harvest(source):(mySource.cache.id=null,report_controller_1.ReportController.email("ERROR: Source cache returned null with get by ID in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)))}}else if(null!=miner.linkIdToDepositTo&&creep.store.energy>creep.store.getCapacity()-2*miner.amountOfWork){const link=Game.getObjectById(miner.linkIdToDepositTo);if(null==link)return miner.linkIdToDepositTo=null,void report_controller_1.ReportController.email("ERROR: A miner's link ID to deposit in was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));creep.transfer(link,RESOURCE_ENERGY)}}else movement_helper_1.MovementHelper.myMoveTo(creep,cachePos,miner)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleHauler=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7);exports.RoleHauler=class{static run(hauler,myRoom){if(creep_helper_1.CreepHelper.handleCreepPreRole(hauler))return;const creep=Game.creeps[hauler.name];if(hauler.pickup||0!==creep.store.getUsedCapacity()?hauler.pickup&&0===creep.store.getFreeCapacity()&&(hauler.pickup=!1,creep.say("delivering")):(hauler.pickup=!0,creep.say("pickup")),hauler.pickup){const cacheToGrabFromPos=room_helper_1.RoomHelper.myPosToRoomPos(hauler.cachePosToPickupFrom);if(cacheToGrabFromPos.isNearTo(creep)){let cacheToGrabFrom=null;const structures=cacheToGrabFromPos.lookFor(LOOK_STRUCTURES);for(let i=0;i<structures.length;i++){const structure=structures[i];structure.structureType===STRUCTURE_CONTAINER&&(cacheToGrabFrom=structure)}if(null==cacheToGrabFrom)return report_controller_1.ReportController.email("Source cache is null for hauler: "+hauler.name+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+". Commiting suicide."),void creep.suicide();if(cacheToGrabFrom.store.getUsedCapacity()>=creep.store.getFreeCapacity()){const resources=Object.keys(cacheToGrabFrom.store);for(let i=0;i<resources.length;i++)creep.withdraw(cacheToGrabFrom,resources[i])}}else movement_helper_1.MovementHelper.myMoveTo(creep,cacheToGrabFromPos,hauler)}else{if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Room's bank memory was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" for hauler");const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const resources=Object.keys(creep.store);for(let i=0;i<resources.length&&creep.transfer(bank,resources[i])!==OK;i++);}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,hauler)}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomStageController=void 0;const stage_default_1=__webpack_require__(24),stage0_1=__webpack_require__(25),stage0_5_1=__webpack_require__(26),stage1_1=__webpack_require__(27),stage1_5_1=__webpack_require__(28),stage2_8_1=__webpack_require__(29),stage2_1=__webpack_require__(30),stage2_5_1=__webpack_require__(31),stage3_1=__webpack_require__(32),stage3_3_1=__webpack_require__(33),stage3_6_1=__webpack_require__(34),stage4_1=__webpack_require__(35),stage4_2_1=__webpack_require__(36),stage4_4_1=__webpack_require__(37),stage4_6_1=__webpack_require__(38),stage4_8_1=__webpack_require__(39),stage5_1=__webpack_require__(40),stage5_2_1=__webpack_require__(41),stage5_4_1=__webpack_require__(42),stage5_6_1=__webpack_require__(43),stage5_8_1=__webpack_require__(44),stage6_1=__webpack_require__(45),stage6_2_1=__webpack_require__(46),stage6_4_1=__webpack_require__(47),stage6_8_1=__webpack_require__(48),stage7_1=__webpack_require__(49),stage7_2_1=__webpack_require__(50),stage7_4_1=__webpack_require__(51),stage7_6_1=__webpack_require__(52),stage7_9_1=__webpack_require__(53),stage6_6_1=__webpack_require__(80),stage7_8_1=__webpack_require__(81),stage7_7_1=__webpack_require__(82),stage2_2_1=__webpack_require__(54);exports.RoomStageController=class{static run(myRoom,room){Game.time%10==0&&(-1===myRoom.roomStage&&stage_default_1.StageDefault.up(myRoom,room),0===myRoom.roomStage&&stage0_1.Stage0.up(myRoom,room),.5===myRoom.roomStage&&stage0_5_1.Stage0_5.up(myRoom,room),1===myRoom.roomStage&&stage1_1.Stage1.up(myRoom,room),1.5===myRoom.roomStage&&stage1_5_1.Stage1_5.up(myRoom,room),2===myRoom.roomStage&&stage2_1.Stage2.up(myRoom,room),2.2===myRoom.roomStage&&stage2_2_1.Stage2_2.up(myRoom,room),2.5===myRoom.roomStage&&stage2_5_1.Stage2_5.up(myRoom,room),2.8===myRoom.roomStage&&stage2_8_1.Stage2_8.up(myRoom,room),3===myRoom.roomStage&&stage3_1.Stage3.up(myRoom,room),3.3===myRoom.roomStage&&stage3_3_1.Stage3_3.up(myRoom,room),3.6===myRoom.roomStage&&stage3_6_1.Stage3_6.up(myRoom,room),4===myRoom.roomStage&&stage4_1.Stage4.up(myRoom,room),4.2===myRoom.roomStage&&stage4_2_1.Stage4_2.up(myRoom,room),4.4===myRoom.roomStage&&stage4_4_1.Stage4_4.up(myRoom,room),4.6===myRoom.roomStage&&stage4_6_1.Stage4_6.up(myRoom,room),4.8===myRoom.roomStage&&stage4_8_1.Stage4_8.up(myRoom,room),5===myRoom.roomStage&&stage5_1.Stage5.up(myRoom,room),5.2===myRoom.roomStage&&stage5_2_1.Stage5_2.up(myRoom,room),5.4===myRoom.roomStage&&stage5_4_1.Stage5_4.up(myRoom,room),5.6===myRoom.roomStage&&stage5_6_1.Stage5_6.up(myRoom,room),5.8===myRoom.roomStage&&stage5_8_1.Stage5_8.up(myRoom,room),6===myRoom.roomStage&&stage6_1.Stage6.up(myRoom,room),6.2===myRoom.roomStage&&stage6_2_1.Stage6_2.up(myRoom,room),6.4===myRoom.roomStage&&stage6_4_1.Stage6_4.up(myRoom,room),6.6===myRoom.roomStage&&stage6_6_1.Stage6_6.up(myRoom,room),6.8===myRoom.roomStage&&stage6_8_1.Stage6_8.up(myRoom,room),7===myRoom.roomStage&&stage7_1.Stage7.up(myRoom,room),7.2===myRoom.roomStage&&stage7_2_1.Stage7_2.up(myRoom,room),7.4===myRoom.roomStage&&stage7_4_1.Stage7_4.up(myRoom,room),7.6===myRoom.roomStage&&stage7_6_1.Stage7_6.up(myRoom,room),7.7===myRoom.roomStage&&stage7_7_1.Stage7_7.up(myRoom,room),7.8===myRoom.roomStage&&stage7_8_1.Stage7_8.up(myRoom,room),7.9===myRoom.roomStage&&stage7_9_1.Stage7_9.up(myRoom,room),myRoom.roomStage>7.9&&stage7_9_1.Stage7_9.down(myRoom,room),myRoom.roomStage>7.8&&stage7_8_1.Stage7_8.down(myRoom,room),myRoom.roomStage>7.7&&stage7_7_1.Stage7_7.down(myRoom,room),myRoom.roomStage>7.6&&stage7_6_1.Stage7_6.down(myRoom,room),myRoom.roomStage>7.4&&stage7_4_1.Stage7_4.down(myRoom,room),myRoom.roomStage>7.2&&stage7_2_1.Stage7_2.down(myRoom,room),myRoom.roomStage>7&&stage7_1.Stage7.down(myRoom,room),myRoom.roomStage>6.8&&stage6_8_1.Stage6_8.down(myRoom,room),myRoom.roomStage>6.6&&stage6_6_1.Stage6_6.down(myRoom,room),myRoom.roomStage>6.4&&stage6_4_1.Stage6_4.down(myRoom,room),myRoom.roomStage>6.2&&stage6_2_1.Stage6_2.down(myRoom,room),myRoom.roomStage>6&&stage6_1.Stage6.down(myRoom,room),myRoom.roomStage>5.8&&stage5_8_1.Stage5_8.down(myRoom,room),myRoom.roomStage>5.6&&stage5_6_1.Stage5_6.down(myRoom,room),myRoom.roomStage>5.4&&stage5_4_1.Stage5_4.down(myRoom,room),myRoom.roomStage>5.2&&stage5_2_1.Stage5_2.down(myRoom,room),myRoom.roomStage>5&&stage5_1.Stage5.down(myRoom,room),myRoom.roomStage>4.8&&stage4_8_1.Stage4_8.down(myRoom,room),myRoom.roomStage>4.6&&stage4_6_1.Stage4_6.down(myRoom,room),myRoom.roomStage>4.4&&stage4_4_1.Stage4_4.down(myRoom,room),myRoom.roomStage>4.2&&stage4_2_1.Stage4_2.down(myRoom,room),myRoom.roomStage>4&&stage4_1.Stage4.down(myRoom,room),myRoom.roomStage>3.6&&stage3_6_1.Stage3_6.down(myRoom,room),myRoom.roomStage>3.3&&stage3_3_1.Stage3_3.down(myRoom,room),myRoom.roomStage>3&&stage3_1.Stage3.down(myRoom,room),myRoom.roomStage>2.8&&stage2_8_1.Stage2_8.down(myRoom,room),myRoom.roomStage>2.6&&stage2_5_1.Stage2_5.down(myRoom,room),myRoom.roomStage>2.3&&stage2_2_1.Stage2_2.down(myRoom,room),myRoom.roomStage>2&&stage2_1.Stage2.down(myRoom,room),myRoom.roomStage>1.3&&stage1_5_1.Stage1_5.down(myRoom,room),myRoom.roomStage>1&&stage1_1.Stage1.down(myRoom,room),myRoom.roomStage>.5&&stage0_5_1.Stage0_5.down(myRoom,room),myRoom.roomStage>0&&stage0_1.Stage0.down(myRoom,room),myRoom.roomStage>-1&&stage_default_1.StageDefault.down(myRoom,room))}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.StageDefault=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.StageDefault=class{static up(myRoom,room){return null!=room.controller&&!0===room.controller.my&&(myRoom.roomStage=0,report_controller_1.ReportController.email("STAGE+ 0 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" my controller"),!0)}static down(myRoom,room){return(null==room.controller||!1===room.controller.my)&&(myRoom.roomStage=-1,report_controller_1.ReportController.email("STAGE- 0 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" my controller"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage0=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.Stage0=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=1&&(myRoom.roomStage=.5,report_controller_1.ReportController.email("STAGE+ 0.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL1"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<1)&&(myRoom.roomStage=0,report_controller_1.ReportController.email("STAGE- 0 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL1"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage0_5=void 0;const report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),memory_controller_1=__webpack_require__(16);exports.Stage0_5=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)>=1&&(myRoom.roomStage=1,report_controller_1.ReportController.email("STAGE+ 1 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 spawn"),!0)}static down(myRoom,room){if(0===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)){for(let i=myRoom.spawnQueue.length;i>0;i--){const queuedCreep=myRoom.spawnQueue[i];for(let j=0;j<myRoom.myCreeps.length;j++)myRoom.myCreeps[j].name===queuedCreep.name&&memory_controller_1.MemoryController.handleCreepDying(myRoom,myRoom.myCreeps[j]);myRoom.spawnQueue.splice(i,1)}return myRoom.roomStage=.5,report_controller_1.ReportController.email("STAGE- 0.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 spawn"),!0}return!1}static step(myRoom,room){0===Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs first spawn, which should be manually placed",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage1=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.Stage1=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=2&&(myRoom.roomStage=1.5,report_controller_1.ReportController.email("STAGE+ 1.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL2"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<2)&&(myRoom.roomStage=1,report_controller_1.ReportController.email("STAGE- 1 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL2"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage1_5=void 0;const stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2);exports.Stage1_5=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=5&&(myRoom.roomStage=2,report_controller_1.ReportController.email("STAGE+ 2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 5 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<5&&(myRoom.roomStage=1.5,report_controller_1.ReportController.email("STAGE- 1.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 5 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,5)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage2_8=void 0;const report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9);exports.Stage2_8=class{static up(myRoom,room){this.step(myRoom,room);for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(!(null!=mySource.cache&&null!=mySource.cache.id||null!=mySource.link&&null!=mySource.link.id))return!1}return myRoom.roomStage=3,report_controller_1.ReportController.email("STAGE+ 3 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" caches"),!0}static down(myRoom,room){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(!(null!=mySource.cache&&null!=mySource.cache.id||null!=mySource.link&&null!=mySource.link.id))return myRoom.roomStage=2.8,report_controller_1.ReportController.email("STAGE- 2.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" caches"),!0}return!1}static step(myRoom,room){const flags=flag_helper_1.FlagHelper.getFlags1(["cont"],myRoom.name);let flagsPlaced=0;for(let i=0;i<flags.length;i++){const roomFlag=flags[i];if(Game.rooms[myRoom.name].createConstructionSite(roomFlag.pos,STRUCTURE_CONTAINER)===OK||this.containerInPos(roomFlag.pos)){let placedFully=!1;for(let j=0;j<myRoom.mySources.length;j++){const mySource=myRoom.mySources[j],source=Game.getObjectById(mySource.id);null==source?report_controller_1.ReportController.email("ERROR: Source was null when trying to get it by ID in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)):source.pos.inRangeTo(roomFlag.pos,1)&&(mySource.cache={pos:{x:roomFlag.pos.x,y:roomFlag.pos.y,roomName:myRoom.name},id:null},mySource.state="Cache",flagsPlaced++,placedFully=!0)}placedFully?(report_controller_1.ReportController.log("Placed container cache construction site in "+log_helper_1.LogHelper.roomNameAsLink(room.name)),roomFlag.remove()):report_controller_1.ReportController.email("ERROR: Placed a construction site at a flag but couldn't find a source to give it to, in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}else report_controller_1.ReportController.email("ERROR: Placing a container cache construction site errored in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(null!=mySource.cache&&null==mySource.cache.id){const structures=room_helper_1.RoomHelper.myPosToRoomPos(mySource.cache.pos).lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_CONTAINER){mySource.cache.id=structures[j].id;break}}}const amountOfContainers=room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_CONTAINER);if(amountOfContainers>=myRoom.mySources.length){const containers=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_CONTAINER});for(let i=0;i<containers.length;i++){const container=containers[i];for(let j=0;j<myRoom.mySources.length;j++){const mySource=myRoom.mySources[j];if("NoCache"!==mySource.state)continue;Game.getObjectById(myRoom.mySources[j].id).pos.inRangeTo(containers[i].pos,1)&&(mySource.state="Cache",mySource.cache={pos:{x:container.pos.x,y:container.pos.y,roomName:myRoom.name},id:container.id},report_controller_1.ReportController.log("Fixed container cache in "+log_helper_1.LogHelper.roomNameAsLink(room.name)))}}}0===room.find(FIND_CONSTRUCTION_SITES).length&&flagsPlaced+amountOfContainers<myRoom.mySources.length&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs cache container flag (cont)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}static containerInPos(pos){const structures=pos.lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_CONTAINER)return!0;return!1}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage2=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.Stage2=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=3&&(myRoom.roomStage=2.2,report_controller_1.ReportController.email("STAGE+ 2.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL3"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<3)&&(myRoom.roomStage=2,report_controller_1.ReportController.email("STAGE- 2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL3"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage2_5=void 0;const stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1);exports.Stage2_5=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=10&&(myRoom.roomStage=2.8,report_controller_1.ReportController.email("STAGE+ 2.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 10 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<10&&(myRoom.roomStage=2.5,report_controller_1.ReportController.email("STAGE- 2.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 10 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,10)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage3=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.Stage3=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=4&&(myRoom.roomStage=3.3,report_controller_1.ReportController.email("STAGE+ 3.3 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL4"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<4)&&(myRoom.roomStage=3,report_controller_1.ReportController.email("STAGE- 3 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL4"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage3_3=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage3_3=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=20&&(myRoom.roomStage=3.6,report_controller_1.ReportController.email("STAGE+ 3.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 20 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<20&&(myRoom.roomStage=3.3,report_controller_1.ReportController.email("STAGE- 3.3 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 20 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,20)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage3_6=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6);exports.Stage3_6=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_STORAGE)>=1&&null!=myRoom.bank&&(myRoom.roomStage=4,report_controller_1.ReportController.email("STAGE+ 4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" bank"),!0)}static down(myRoom,room){return(room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_STORAGE)<1||null==myRoom.bank)&&(myRoom.roomStage=3.6,report_controller_1.ReportController.email("STAGE- 3.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" bank"),!0)}static step(myRoom,room){const storageFlag=flag_helper_1.FlagHelper.getFlag1(["storage"],myRoom.name);let placedBank=!1;if(null!=storageFlag){Game.rooms[myRoom.name].createConstructionSite(storageFlag.pos,STRUCTURE_STORAGE)===OK?(report_controller_1.ReportController.log("Placed storage bank construction site in "+log_helper_1.LogHelper.roomNameAsLink(room.name)),storageFlag.remove(),placedBank=!0):report_controller_1.ReportController.email("ERROR: Placing a storage bank construction site errored in "+log_helper_1.LogHelper.roomNameAsLink(room.name))}const bankLinkerPosFlag=flag_helper_1.FlagHelper.getFlag1(["bank","linker","pos"],myRoom.name),storage=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_STORAGE});null!=bankLinkerPosFlag?1===storage.length?(myRoom.bank={bankPos:{x:storage[0].pos.x,y:storage[0].pos.y,roomName:myRoom.name},bankLinkerName:null,bankLinkerPos:room_helper_1.RoomHelper.roomPosToMyPos(bankLinkerPosFlag.pos),bankLink:null,object:storage[0]},bankLinkerPosFlag.remove()):0!==Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length||0!==storage.length||placedBank||report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs a bank flag (storage)",report_cooldown_constants_1.ReportCooldownConstants.DAY):0!==storage.length&&null!=myRoom.bank||report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs a bank linker pos flag (bank-linker-pos)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage4=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.Stage4=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=5&&(myRoom.roomStage=4.2,report_controller_1.ReportController.email("STAGE+ 4.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL5"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<5)&&(myRoom.roomStage=4,report_controller_1.ReportController.email("STAGE- 4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL5"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage4_2=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage4_2=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)>=2&&(myRoom.roomStage=4.4,report_controller_1.ReportController.email("STAGE+ 4.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 towers"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)<2&&(myRoom.roomStage=4.2,report_controller_1.ReportController.email("STAGE- 4.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 towers"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildTowers(myRoom,room,2)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage4_4=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage4_4=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=30&&(myRoom.roomStage=4.6,report_controller_1.ReportController.email("STAGE+ 4.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 30 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<30&&(myRoom.roomStage=4.4,report_controller_1.ReportController.email("STAGE- 4.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 30 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,30)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage4_6=void 0;const stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9);exports.Stage4_6=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)>=2&&(myRoom.roomStage=4.8,report_controller_1.ReportController.email("STAGE+ 4.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 links"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)<2&&(myRoom.roomStage=4.6,report_controller_1.ReportController.email("STAGE- 4.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 links"),!0)}static step(myRoom,room){const flag=flag_helper_1.FlagHelper.getFlag1(["link","bank"],myRoom.name);let placedBankLink=!1;if(null!=flag){Game.rooms[myRoom.name].createConstructionSite(flag.pos,STRUCTURE_LINK)===OK?(myRoom.bank.bankLink={pos:room_helper_1.RoomHelper.roomPosToMyPos(flag.pos),id:null},flag.remove(),placedBankLink=!0,report_controller_1.ReportController.log("Placed a bank link construction site in "+log_helper_1.LogHelper.roomNameAsLink(room.name))):report_controller_1.ReportController.email("ERROR: Placing a bank link construction site errored in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}if(null!=myRoom.bank.bankLink){const structures=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankLink.pos).lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_LINK){myRoom.bank.bankLink.id=structures[j].id;break}}placedBankLink||0!==Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length||report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs bank link flag (link-bank-X)",report_cooldown_constants_1.ReportCooldownConstants.DAY),stage_functions_1.StageFunctions.setupSourceLink(myRoom)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage4_8=void 0;const log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage4_8=class{static up(myRoom,room){this.step(myRoom,room);for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if("Link"===mySource.state&&null!=mySource.link&&null!=mySource.link.id&&null!=mySource.cache&&null==mySource.cache.id&&null==mySource.haulerName)return myRoom.roomStage=5,report_controller_1.ReportController.email("STAGE+ 5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 source using links"),!0}return!1}static down(myRoom,room){let foundLinkedSource=!1;for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if("Link"===mySource.state&&null!=mySource.link&&null!=mySource.link.id&&null!=mySource.cache&&null==mySource.cache.id&&null==mySource.haulerName){foundLinkedSource=!0;break}}return!foundLinkedSource&&(myRoom.roomStage=4.8,report_controller_1.ReportController.email("STAGE- 4.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 source using links"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.clearHaulersAndCaches(myRoom)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage5=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.Stage5=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=6&&(myRoom.roomStage=5.2,report_controller_1.ReportController.email("STAGE+ 5.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL6"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<6)&&(myRoom.roomStage=5,report_controller_1.ReportController.email("STAGE- 5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL6"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage5_2=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage5_2=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)>myRoom.mySources.length&&(myRoom.roomStage=5.4,report_controller_1.ReportController.email("STAGE+ 5.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" all sources linked"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)<=myRoom.mySources.length&&(myRoom.roomStage=5.2,report_controller_1.ReportController.email("STAGE- 5.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" all sources linked"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.setupSourceLink(myRoom),stage_functions_1.StageFunctions.clearHaulersAndCaches(myRoom)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage5_4=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage5_4=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=40&&(myRoom.roomStage=5.6,report_controller_1.ReportController.email("STAGE+ 5.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 40 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<40&&(myRoom.roomStage=5.4,report_controller_1.ReportController.email("STAGE- 5.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 40 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,40)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage5_6=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),flag_helper_1=__webpack_require__(9);exports.Stage5_6=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTRACTOR)>=1&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_CONTAINER)>=1&&(myRoom.roomStage=5.8,report_controller_1.ReportController.email("STAGE+ 5.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" extractor + digger cont"),!0)}static down(myRoom,room){return(room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTRACTOR)<1||room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_CONTAINER)<1)&&(myRoom.roomStage=5.6,report_controller_1.ReportController.email("STAGE- 5.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" extractor + digger cont"),!0)}static step(myRoom,room){let placedSomething=!1;const minerals=room.find(FIND_MINERALS);if(1===minerals.length){minerals[0].pos.createConstructionSite(STRUCTURE_EXTRACTOR)===OK&&(placedSomething=!0)}const flag=flag_helper_1.FlagHelper.getFlag1(["digger","cont"],myRoom.name);if(null!=flag){flag.remove();flag.pos.createConstructionSite(STRUCTURE_CONTAINER)===OK&&(placedSomething=!0)}const extractors=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_EXTRACTOR});if(1===extractors.length){const containers=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_CONTAINER});for(let i=0;i<containers.length;i++){const container=containers[i];extractors[0].pos.inRangeTo(containers[i].pos,1)&&(myRoom.digging.cache={pos:{x:container.pos.x,y:container.pos.y,roomName:myRoom.name},id:container.id})}}!placedSomething&&0===room.find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_CONTAINER)<1&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs a digger cont (digger-cont)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage5_8=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6);exports.Stage5_8=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TERMINAL)>=1&&(myRoom.roomStage=6,report_controller_1.ReportController.email("STAGE+ 6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" terminal"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TERMINAL)<1&&(myRoom.roomStage=5.8,report_controller_1.ReportController.email("STAGE- 5.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" terminal"),!0)}static step(myRoom,room){const flag=flag_helper_1.FlagHelper.getFlag1(["terminal"],myRoom.name);let placedTerminal=!1;if(null!=flag){flag.pos.createConstructionSite(STRUCTURE_TERMINAL)===OK&&(placedTerminal=!0,flag.remove())}!placedTerminal&&0===room.find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TERMINAL)<1&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs a terminal flag (terminal)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage6=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.Stage6=class{static up(myRoom,room){return null!=room.controller&&room.controller.level>=7&&(myRoom.roomStage=6.2,report_controller_1.ReportController.email("STAGE+ 6.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL7"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<7)&&(myRoom.roomStage=0,report_controller_1.ReportController.email("STAGE- 6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL7"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage6_2=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage6_2=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)>=3&&(myRoom.roomStage=6.4,report_controller_1.ReportController.email("STAGE+ 6.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 3 towers"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)<3&&(myRoom.roomStage=6.2,report_controller_1.ReportController.email("STAGE- 6.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 3 towers"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildTowers(myRoom,room,3)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage6_4=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage6_4=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)>=50&&(myRoom.roomStage=6.6,report_controller_1.ReportController.email("STAGE+ 6.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 50 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<50&&(myRoom.roomStage=6.4,report_controller_1.ReportController.email("STAGE- 6.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 50 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,50)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage6_8=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),stage_functions_1=__webpack_require__(5);exports.Stage6_8=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)>=2&&(myRoom.roomStage=7,report_controller_1.ReportController.email("STAGE+ 7 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 spawns"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)<2&&(myRoom.roomStage=6.8,report_controller_1.ReportController.email("STAGE- 6.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 2 spawns"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildSpawns(myRoom,room,2)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7=void 0;const log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0);exports.Stage7=class{static up(myRoom,room){return null!=room.controller&&8===room.controller.level&&(myRoom.roomStage=7.2,report_controller_1.ReportController.email("STAGE+ 7.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL8"),!0)}static down(myRoom,room){return(null==room.controller||room.controller.level<8)&&(myRoom.roomStage=7,report_controller_1.ReportController.email("STAGE- 7 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" RCL8"),!0)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_2=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage7_2=class{static up(myRoom,room){return this.step(myRoom,room),6===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)&&(myRoom.roomStage=7.4,report_controller_1.ReportController.email("STAGE+ 7.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 6 towers"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)<6&&(myRoom.roomStage=7.2,report_controller_1.ReportController.email("STAGE- 7.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 6 towers"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildTowers(myRoom,room,6)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_4=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0);exports.Stage7_4=class{static up(myRoom,room){return this.step(myRoom,room),60===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)&&(myRoom.roomStage=7.6,report_controller_1.ReportController.email("STAGE+ 7.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 60 extensions"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_EXTENSION)<60&&(myRoom.roomStage=7.4,report_controller_1.ReportController.email("STAGE- 7.4 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 60 extensions"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildExtensions(myRoom,room,60)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_6=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),stage_functions_1=__webpack_require__(5);exports.Stage7_6=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)>=3&&(myRoom.roomStage=7.7,report_controller_1.ReportController.email("STAGE+ 7.7 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 3 spawns"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_SPAWN)<3&&(myRoom.roomStage=7.6,report_controller_1.ReportController.email("STAGE- 7.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 3 spawns"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildSpawns(myRoom,room,3)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_9=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),flag_helper_1=__webpack_require__(9),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6);exports.Stage7_9=class{static up(myRoom,room){return this.step(myRoom,room),1===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_POWER_SPAWN)&&null!=myRoom.powerSpawn&&(myRoom.roomStage=8,report_controller_1.ReportController.email("STAGE+ 8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 power spawn"),!0)}static down(myRoom,room){return(room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_POWER_SPAWN)<1||null==myRoom.powerSpawn)&&(myRoom.powerSpawn=null,myRoom.roomStage=7.9,report_controller_1.ReportController.email("STAGE- 7.9 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 power spawn"),!0)}static step(myRoom,room){const flag=flag_helper_1.FlagHelper.getFlag1(["power","spawn"],myRoom.name);let placedPowerSpawn=!1;if(null!=flag){flag.pos.createConstructionSite(STRUCTURE_POWER_SPAWN)===OK&&(placedPowerSpawn=!0,flag.remove())}1===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_POWER_SPAWN)?myRoom.powerSpawn={resources:"Restock"}:!placedPowerSpawn&&0===room.find(FIND_CONSTRUCTION_SITES).length&&room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_POWER_SPAWN)<1&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs a power spawn flag (power-spawn)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage2_2=void 0;const stage_functions_1=__webpack_require__(5),report_controller_1=__webpack_require__(0),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1);exports.Stage2_2=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)>=1&&(myRoom.roomStage=2.5,report_controller_1.ReportController.email("STAGE+ 2.5 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 tower"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_TOWER)<1&&(myRoom.roomStage=2.2,report_controller_1.ReportController.email("STAGE- 2.2 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 1 tower"),!0)}static step(myRoom,room){stage_functions_1.StageFunctions.buildTowers(myRoom,room,1)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleLaborer=void 0;const report_controller_1=__webpack_require__(0),constants_1=__webpack_require__(4),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7);exports.RoleLaborer=class{static run(laborer,myRoom,laborersStock){if(creep_helper_1.CreepHelper.handleCreepPreRole(laborer))return;const creep=Game.creeps[laborer.name];this.calculateCreepState(laborer,myRoom,creep),"Labor"===laborer.state?this.labor(laborer,myRoom,creep,laborersStock):"PickupBank"===laborer.state?this.pickupBank(laborer,myRoom,creep):"PickupControllerLink"===laborer.state?this.pickupControllerLink(laborer,myRoom,creep):"PickupCache"===laborer.state?this.pickupCache(laborer,myRoom,creep):this.mining(laborer,myRoom,creep)}static calculateCreepState(laborer,myRoom,creep){if("Labor"===laborer.state&&0===creep.store.energy){let distanceToControllerLink=999;if(null!=myRoom.controllerLink&&null!=myRoom.controllerLink.id){const controllerLink=Game.getObjectById(myRoom.controllerLink.id);null!=controllerLink&&controllerLink.store.energy>=creep.store.getCapacity()&&(distanceToControllerLink=creep.pos.getRangeTo(controllerLink))}const bank=null==myRoom.bank?null:myRoom.bank.object;if(null!=bank&&bank.store[RESOURCE_ENERGY]>=creep.store.getCapacity()&&creep.pos.getRangeTo(bank)<distanceToControllerLink)return laborer.state="PickupBank",void creep.say("PickupBank");if(999!==distanceToControllerLink)return laborer.state="PickupControllerLink",void creep.say("PickupCnLink");if(myRoom.roomStage>=1){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(null!=mySource.cache&&null!=mySource.cache.id){const cache=Game.getObjectById(mySource.cache.id);if(null==cache)mySource.cache.id=null,report_controller_1.ReportController.email("ERROR: Source cache returned null with get by ID in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));else if(cache.store[RESOURCE_ENERGY]>=creep.store.getCapacity())return laborer.state="PickupCache",void creep.say("PickupCache")}}return laborer.state="Mining",void creep.say("Mining")}return laborer.state="Mining",void creep.say("Mining")}"Labor"!==laborer.state&&creep.store.energy===creep.store.getCapacity()&&(laborer.state="Labor",creep.say("work work"))}static pickupControllerLink(laborer,myRoom,creep){if(null==myRoom.controllerLink||null==myRoom.controllerLink.id)return;const controllerLinkPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.controllerLink.pos);if(controllerLinkPos.isNearTo(creep)){const controllerLink=Game.getObjectById(myRoom.controllerLink.id);if(null==controllerLink)return void report_controller_1.ReportController.email("ERROR: Room's controller link was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));creep.withdraw(controllerLink,RESOURCE_ENERGY)}else movement_helper_1.MovementHelper.myMoveTo(creep,controllerLinkPos,laborer)}static pickupBank(laborer,myRoom,creep){if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Room's bank memory was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" for laborer");const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));creep.withdraw(bank,RESOURCE_ENERGY)}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,laborer)}static pickupCache(laborer,myRoom,creep){const validCacheToGrabFrom=creep.pos.findClosestByPath(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_CONTAINER&&structure.store[RESOURCE_ENERGY]>=creep.store.getCapacity()});null==validCacheToGrabFrom?(laborer.state="Mining",creep.say("Mining")):validCacheToGrabFrom.pos.isNearTo(creep)?creep.withdraw(validCacheToGrabFrom,RESOURCE_ENERGY):movement_helper_1.MovementHelper.myMoveTo(creep,validCacheToGrabFrom.pos,laborer)}static mining(laborer,myRoom,creep){const source=creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);null!=source&&creep.harvest(source)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,source.pos,laborer)}static labor(laborer,myRoom,creep,laborersStock){let givenCommand=!1,forceUpgradeController=!1;if(null!=creep.room.controller&&creep.room.controller.ticksToDowngrade<constants_1.Constants.LABORERS_UPGRADE_WHEN_CONTROLLER_BENEATH&&(forceUpgradeController=!0,givenCommand=!0),laborersStock&&!givenCommand){let structureToAddTo=creep.pos.findClosestByPath(FIND_STRUCTURES,{filter:structure=>(structure.structureType===STRUCTURE_EXTENSION||structure.structureType===STRUCTURE_SPAWN)&&structure.energy<structure.energyCapacity});null==structureToAddTo&&(structureToAddTo=creep.pos.findClosestByPath(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TOWER&&structure.energy<constants_1.Constants.STOCK_TOWER_TO})),null!=structureToAddTo&&(givenCommand=!0,creep.transfer(structureToAddTo,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,structureToAddTo.pos,laborer))}if(!givenCommand){const closestConstructionSite=creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);null!=closestConstructionSite&&(givenCommand=!0,creep.build(closestConstructionSite)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,closestConstructionSite.pos,laborer))}!forceUpgradeController&&givenCommand||creep.upgradeController(creep.room.controller)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,creep.room.controller.pos,laborer)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomSpawnController=void 0;const spawn_laborer_1=__webpack_require__(57),spawn_hauler_1=__webpack_require__(58),spawn_stocker_1=__webpack_require__(59),spawn_miner_1=__webpack_require__(60),spawn_claimer_controller_1=__webpack_require__(17),spawn_bank_linker_1=__webpack_require__(61),report_controller_1=__webpack_require__(0),attack_helper_functions_1=__webpack_require__(12),creep_helper_1=__webpack_require__(3),scavenge_controller_1=__webpack_require__(13),spawn_digger_1=__webpack_require__(83),spawn_upgrader_1=__webpack_require__(84),power_bank_controller_1=__webpack_require__(14);exports.RoomSpawnController=class{static run(myRoom,room){if(Game.time%10==0&&(spawn_laborer_1.SpawnLaborer.laborerSpawnLogic(myRoom,room),spawn_hauler_1.SpawnHauler.spawnHaulerLogic(myRoom),spawn_stocker_1.SpawnStocker.spawnStocker(myRoom),spawn_miner_1.SpawnMiner.minerSpawnLogic(myRoom),spawn_bank_linker_1.SpawnBankLinker.spawnBankLinker(myRoom),spawn_digger_1.SpawnDigger.spawnDigger(myRoom),spawn_upgrader_1.SpawnUpgrader.spawnUpgraderLogic(myRoom)),0===myRoom.spawnQueue.length)return;const creepToSpawn=myRoom.spawnQueue[0],body=this.getBody(creepToSpawn,myRoom),energyCost=creep_helper_1.CreepHelper.bodyCost(body);if(room.energyAvailable<energyCost)return;const spawns=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_SPAWN});let spawn=null;for(let i=0;i<spawns.length;i++)if(null==spawns[i].spawning){spawn=spawns[i];break}if(null==spawn)return;spawn.spawnCreep(body,creepToSpawn.name)===OK&&myRoom.spawnQueue.splice(0,1)}static getBody(queuedCreep,myRoom){if("ForceLaborer"===queuedCreep.role)return spawn_laborer_1.SpawnLaborer.getForceBody(myRoom);if("Stocker"===queuedCreep.role)return spawn_stocker_1.SpawnStocker.getBody(myRoom);if("Claimer"===queuedCreep.role)return spawn_claimer_controller_1.SpawnClaimerController.getBody(myRoom);if("Miner"===queuedCreep.role)for(let k=0;k<myRoom.mySources.length;k++){const mySource=myRoom.mySources[k];if(mySource.minerName===queuedCreep.name)return spawn_miner_1.SpawnMiner.getBody(myRoom,mySource)}else{if("Hauler"===queuedCreep.role)return spawn_hauler_1.SpawnHauler.getBody(myRoom);if("Upgrader"===queuedCreep.role)return spawn_upgrader_1.SpawnUpgrader.getBody(myRoom);if("BankLinker"===queuedCreep.role)return spawn_bank_linker_1.SpawnBankLinker.getBody();if("Laborer"===queuedCreep.role)return spawn_laborer_1.SpawnLaborer.getBody(myRoom);if("Digger"===queuedCreep.role)return spawn_digger_1.SpawnDigger.getBody(myRoom);if("PowerBankAttackCreep"===queuedCreep.role)return power_bank_controller_1.PowerBankController.getAttackerBody();if("PowerBankHealCreep"===queuedCreep.role)return power_bank_controller_1.PowerBankController.getHealerBody();if("Scavenger"===queuedCreep.role)return scavenge_controller_1.ScavengeController.getBody(myRoom);if("AttackQuickCreep"===queuedCreep.role||"AttackPressureCreep"===queuedCreep.role)return attack_helper_functions_1.AttackHelperFunctions.getBody(myRoom);if("Legolas"===queuedCreep.role)return creep_helper_1.CreepHelper.generateBody([RANGED_ATTACK,MOVE],[RANGED_ATTACK,MOVE],Game.rooms[myRoom.name],!0);if("Signer"===queuedCreep.role)return[MOVE]}return report_controller_1.ReportController.email("ERROR: Creep role doesn't have a getBody function "+queuedCreep.role),[]}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnLaborer=void 0;const constants_1=__webpack_require__(4),report_controller_1=__webpack_require__(0),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),map_helper_1=__webpack_require__(11),report_cooldown_constants_1=__webpack_require__(6),flag_helper_1=__webpack_require__(9);class SpawnLaborer{static laborerSpawnLogic(myRoom,room){myRoom.roomStage>=constants_1.Constants.CONTROLLER_LINKED_STAGE?this.linkedControllerSpawnLogic(myRoom,room):myRoom.roomStage>=constants_1.Constants.BANK_LINKED_STAGE?this.linkedRoomSpawnLogic(myRoom,room):myRoom.roomStage>=1?this.nonLinkedRoomSpawnLogic(myRoom,room):this.noSpawnLogic(myRoom,room)}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,MOVE,CARRY,WORK],[MOVE,MOVE,CARRY,WORK],Game.rooms[myRoom.name],!0)}static getForceBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,MOVE,CARRY,WORK],[MOVE,MOVE,CARRY,WORK],Game.rooms[myRoom.name],!1)}static linkedControllerSpawnLogic(myRoom,room){let roomLooksStable=!1;if(300===room.energyAvailable){let minerAliveOrSpawning=!1;for(let i=0;i<myRoom.myCreeps.length;i++){const myCreep=myRoom.myCreeps[i];if("Laborer"===myCreep.role){if("alive"===myCreep.spawningStatus){roomLooksStable=!0;break}for(let j=0;j<myRoom.spawnQueue.length;j++)"ForceLaborer"===myRoom.spawnQueue[j].role&&myRoom.spawnQueue[j].name===myCreep.name&&(roomLooksStable=!0)}else"alive"!==myCreep.spawningStatus&&"spawning"!==myCreep.spawningStatus||"Miner"===myCreep.role&&(minerAliveOrSpawning=!0)}minerAliveOrSpawning&&(roomLooksStable=!0),roomLooksStable||report_controller_1.ReportController.email("RUT: Fixing a 300 energy room by spawning a forced laborer "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}else roomLooksStable=!0;if(!(0===room.find(FIND_CONSTRUCTION_SITES).length&&room.controller.ticksToDowngrade>=constants_1.Constants.STAGE_8_SPAWN_LABORERS_WHEN_CONTROLLER_BENEATH&&roomLooksStable)){for(let i=0;i<myRoom.myCreeps.length;i++){if("Laborer"===myRoom.myCreeps[i].role)return}SpawnLaborer.forceSpawnLaborers(myRoom,1)}}static linkedRoomSpawnLogic(myRoom,room){let bankLinkerAliveOrSpawning=!1,minersAliveOrSpawningCount=0,stockerAliveOrSpawning=!1,laborerAliveOrSpawningCount=0,forceLaborerQueuedCount=0,laborerCount=0;for(let i=0;i<myRoom.myCreeps.length;i++){const myCreep=myRoom.myCreeps[i];if("Laborer"===myCreep.role)if(laborerCount++,"queued"!==myCreep.spawningStatus)laborerAliveOrSpawningCount++;else for(let j=0;j<myRoom.spawnQueue.length;j++)"ForceLaborer"===myRoom.spawnQueue[j].role&&myRoom.spawnQueue[j].name===myCreep.name&&forceLaborerQueuedCount++;else"BankLinker"===myCreep.role?bankLinkerAliveOrSpawning=!0:"Stocker"===myCreep.role?stockerAliveOrSpawning=!0:"Miner"===myCreep.role&&minersAliveOrSpawningCount++}let forceSpawnlaborers=0;if((!bankLinkerAliveOrSpawning||minersAliveOrSpawningCount<myRoom.mySources.length||!stockerAliveOrSpawning)&&0===laborerAliveOrSpawningCount&&0===forceLaborerQueuedCount&&room.energyAvailable<4e3&&(forceSpawnlaborers=1),forceSpawnlaborers>0)SpawnLaborer.forceSpawnLaborers(myRoom,forceSpawnlaborers);else{let maxLaborers=constants_1.Constants.MAX_LABORERS;8===myRoom.roomStage&&0===room.find(FIND_CONSTRUCTION_SITES).length&&(maxLaborers=constants_1.Constants.MAX_LABORERS_STAGE_8),SpawnLaborer.trySpawnLaborer(myRoom,laborerCount,maxLaborers)}}static noSpawnLogic(myRoom,room){let laborerCount=0;for(let i=0;i<myRoom.myCreeps.length;i++){"Laborer"===myRoom.myCreeps[i].role&&laborerCount++}let forceSpawnlaborers=0;laborerCount<constants_1.Constants.LABORERS_NO_SPAWN&&(forceSpawnlaborers=constants_1.Constants.LABORERS_NO_SPAWN-laborerCount),forceSpawnlaborers>=1&&laborerCount>0&&null!=flag_helper_1.FlagHelper.getFlag1(["life","support"],myRoom.name)||forceSpawnlaborers>0&&SpawnLaborer.forceSpawnLaborers(myRoom,forceSpawnlaborers)}static nonLinkedRoomSpawnLogic(myRoom,room){let laborerCount=0,laborerAliveOrSpawningCount=0,forceLaborerQueuedCount=0;for(let i=0;i<myRoom.myCreeps.length;i++){const myCreep=myRoom.myCreeps[i];if("Laborer"===myCreep.role)if(laborerCount++,"queued"!==myCreep.spawningStatus)laborerAliveOrSpawningCount++;else for(let j=0;j<myRoom.spawnQueue.length;j++)"ForceLaborer"===myRoom.spawnQueue[j].role&&myRoom.spawnQueue[j].name===myCreep.name&&forceLaborerQueuedCount++}let forceSpawnlaborers=0;if(0===laborerAliveOrSpawningCount&&0===forceLaborerQueuedCount&&myRoom.roomStage>=1?forceSpawnlaborers=1:laborerCount<constants_1.Constants.MIN_LABORERS&&(forceSpawnlaborers=constants_1.Constants.MIN_LABORERS-laborerCount),forceSpawnlaborers>0)SpawnLaborer.forceSpawnLaborers(myRoom,forceSpawnlaborers);else{let maxLaborers=constants_1.Constants.MAX_LABORERS;8===myRoom.roomStage&&0===room.find(FIND_CONSTRUCTION_SITES).length&&(maxLaborers=constants_1.Constants.MAX_LABORERS_STAGE_8),SpawnLaborer.trySpawnLaborer(myRoom,laborerCount,maxLaborers)}}static trySpawnLaborer(myRoom,laborerCount,maxLaborers){let spawn=myRoom.roomStage<4&&laborerCount<constants_1.Constants.LABORERS_BEFORE_BANK;if(!spawn){if(null==myRoom.bank)return;const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Bank is null when checking if it's full in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const amountOfEnergyRequired=8===myRoom.roomStage?constants_1.Constants.AMOUNT_OF_BANK_ENERGY_TO_SPAWN_LABORER_STAGE_8:constants_1.Constants.AMOUNT_OF_BANK_ENERGY_TO_SPAWN_LABORER;spawn=bank.store[RESOURCE_ENERGY]>=amountOfEnergyRequired&&laborerCount<maxLaborers&&laborerCount<Math.floor(bank.store[RESOURCE_ENERGY]/constants_1.Constants.AMOUNT_OF_BANK_ENERGY_TO_SPAWN_LABORER)}if(spawn){const newCreep=this.spawnLaborer(myRoom,!1);if(null==newCreep)return;myRoom.myCreeps.push(newCreep)}}static forceSpawnLaborers(myRoom,amount){for(let i=0;i<amount;i++){const newCreep=this.spawnLaborer(myRoom,!0);if(null==newCreep)return;myRoom.myCreeps.push(newCreep),report_controller_1.ReportController.log("Force queued a new Laborer in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}}static spawnLaborer(myRoom,forceSpawn){let roomToSpawnFromName,roomToSpawnFrom;if(0===Game.rooms[myRoom.name].find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_SPAWN}).length){if(roomToSpawnFromName=map_helper_1.MapHelper.findClosestSpawnRoomName(new RoomPosition(25,25,myRoom.name),4),null==roomToSpawnFromName)return report_controller_1.ReportController.email("ERROR: Couldn't find any spawns to make a laborer for "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name),report_cooldown_constants_1.ReportCooldownConstants.DAY),null;roomToSpawnFrom=room_helper_1.RoomHelper.getMyRoomByName(roomToSpawnFromName)}else roomToSpawnFrom=myRoom;const name=creep_helper_1.CreepHelper.getName(),priority=forceSpawn?spawn_constants_1.SpawnConstants.FORCE_LABORER:spawn_constants_1.SpawnConstants.LABORER,roleInQueue=forceSpawn?"ForceLaborer":"Laborer";return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(roomToSpawnFrom,priority,name,roleInQueue),{name:name,role:"Laborer",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},state:"Labor"}}}exports.SpawnLaborer=SpawnLaborer},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnHauler=void 0;const constants_1=__webpack_require__(4),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3);exports.SpawnHauler=class{static spawnHaulerLogic(myRoom){myRoom.roomStage<4||(this.sourceLogic(myRoom),this.diggingLogic(myRoom))}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,CARRY],[MOVE,CARRY],Game.rooms[myRoom.name],!0,20)}static diggingLogic(myRoom){if(Game.time%100!=0)return;if(myRoom.roomStage<constants_1.Constants.MINERAL_START_STAGE||!myRoom.digging.active||null!=myRoom.digging.haulerName||null==myRoom.digging.cache)return;{const minerals=Game.rooms[myRoom.name].find(FIND_MINERALS);if(1===minerals.length&&0===minerals[0].mineralAmount)return}const hauler=this.spawnHaulerInternalForDigging(myRoom);myRoom.myCreeps.push(hauler),myRoom.digging.haulerName=hauler.name}static sourceLogic(myRoom){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];if(null==mySource.cache||null==mySource.cache.id)continue;const myCache=Game.getObjectById(mySource.cache.id);if("Cache"===mySource.state&&null==mySource.haulerName&&null!=myCache&&myCache.store.energy>=myCache.store.getCapacity()*constants_1.Constants.PERCENT_OF_CACHE_ENERGY_TO_SPAWN_HAULER){const newCreep=this.spawnHaulerInternalForSource(myRoom,mySource);myRoom.myCreeps.push(newCreep),mySource.haulerName=newCreep.name}}}static spawnHaulerInternalForSource(myRoom,mySource){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.HAULER,name,"Hauler"),{name:name,role:"Hauler",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},cachePosToPickupFrom:mySource.cache.pos,pickup:!0}}static spawnHaulerInternalForDigging(myRoom){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.DIGGING_HAULER,name,"Hauler"),{name:name,role:"Hauler",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},cachePosToPickupFrom:myRoom.digging.cache.pos,pickup:!0}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnStocker=void 0;const constants_1=__webpack_require__(4),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3);exports.SpawnStocker=class{static spawnStocker(myRoom){if(myRoom.roomStage<4)return;if(myRoom.bank.object.store.energy<1250)return;let amountOfStockers=0;for(let i=0;i<myRoom.myCreeps.length;i++){"Stocker"===myRoom.myCreeps[i].role&&amountOfStockers++}if(amountOfStockers<constants_1.Constants.MAX_STOCKERS)for(let i=0;i<constants_1.Constants.MAX_STOCKERS-amountOfStockers;i++){const newCreep=this.spawnStockerInternal(myRoom);myRoom.myCreeps.push(newCreep)}}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,CARRY],[MOVE,CARRY],Game.rooms[myRoom.name],!1)}static spawnStockerInternal(myRoom){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.STOCKER,name,"Stocker"),{name:name,role:"Stocker",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},state:"PickupEnergy"}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnMiner=void 0;const spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3);exports.SpawnMiner=class{static minerSpawnLogic(myRoom){for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];null==mySource.minerName&&this.spawnMiner(myRoom,mySource)}}static spawnMiner(myRoom,mySource){if(!(myRoom.roomStage<3))if(null!=mySource.minerName);else{const newCreep=this.spawnMinerInternal(myRoom,mySource);myRoom.myCreeps.push(newCreep)}}static getBody(myRoom,mySource){let body,maxBodyParts;return maxBodyParts=1===myRoom.mySources.length?null==mySource.link?12:14:null==mySource.link?18:28,body=null!=mySource.link&&null!=mySource.link.id?creep_helper_1.CreepHelper.generateBody([MOVE,CARRY,WORK,WORK,WORK,WORK,WORK],[MOVE,CARRY,WORK,WORK,WORK,WORK,WORK],Game.rooms[myRoom.name],!1,maxBodyParts):creep_helper_1.CreepHelper.generateBody([MOVE,WORK,WORK,WORK,WORK,WORK],[MOVE,WORK,WORK,WORK,WORK,WORK],Game.rooms[myRoom.name],!1,maxBodyParts),body}static spawnMinerInternal(myRoom,mySource){const name=creep_helper_1.CreepHelper.getName();spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.MINER,name,"Miner");let linkId=null;return null!=mySource.link&&null!=mySource.link.id&&(linkId=mySource.link.id),mySource.minerName=name,{name:name,role:"Miner",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},cachePosToMineOn:mySource.cache.pos,linkIdToDepositTo:linkId,sourceId:mySource.id,amountOfWork:0}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnBankLinker=void 0;const spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3);exports.SpawnBankLinker=class{static spawnBankLinker(myRoom){if(myRoom.roomStage<5)return;if(null!=myRoom.bank.bankLinkerName)return;const bankLinker=this.spawnBankLinkerInternal(myRoom);myRoom.myCreeps.push(bankLinker),myRoom.bank.bankLinkerName=bankLinker.name}static getBody(){return[MOVE,CARRY,CARRY]}static spawnBankLinkerInternal(myRoom){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.BANK_LINKER,name,"BankLinker"),{name:name,role:"BankLinker",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},inPos:!1,state:"Default"}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RolePowerBankAttackCreep=void 0;const creep_helper_1=__webpack_require__(3),movement_helper_1=__webpack_require__(7),report_controller_1=__webpack_require__(0);exports.RolePowerBankAttackCreep=class{static run(powerBankAttack,myPowerBank,powerBank,powerBankHeal){if(creep_helper_1.CreepHelper.handleCreepPreRole(powerBankAttack))return;const creep=Game.creeps[powerBankAttack.name];if(null==powerBank)return creep.say("dthb4dshnr"),void creep.suicide();creep.pos.isNearTo(powerBank)?creep.hits!==creep.hitsMax&&null!=powerBankHeal||(creep.attack(powerBank),powerBankAttack.reachedPowerBank||(report_controller_1.ReportController.log("Power Bank Attack Creep reached power bank"),powerBankAttack.reachedPowerBank=!0)):movement_helper_1.MovementHelper.myMoveTo(creep,powerBank.pos,powerBankAttack)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleBankLinker=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7),room_helper_1=__webpack_require__(2),constants_1=__webpack_require__(4),report_cooldown_constants_1=__webpack_require__(6);exports.RoleBankLinker=class{static run(bankLinker,myRoom,transfer,bankLinkerShouldStockLink){if(creep_helper_1.CreepHelper.handleCreepPreRole(bankLinker))return;if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: BankMemory was null for a bank linker in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const creep=Game.creeps[bankLinker.name];if(!bankLinker.inPos){const position=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankLinkerPos);if(0!==creep.pos.getRangeTo(position))return void movement_helper_1.MovementHelper.myMoveTo(creep,position,bankLinker);bankLinker.inPos=!0}const room=Game.rooms[myRoom.name],bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Bank was null for a bank linker in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));if(null==myRoom.bank.bankLink||null==myRoom.bank.bankLink.id)return void report_controller_1.ReportController.email("ERROR: Bank Link was null for a bank linker in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const link=Game.getObjectById(myRoom.bank.bankLink.id);null!=link?this.creepLogic(bankLinker,room,creep,bank,link,transfer,bankLinkerShouldStockLink):report_controller_1.ReportController.email("ERROR: Bank Link was null for a bank linker in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}static creepLogic(bankLinker,room,creep,bank,link,transfer,bankLinkerShouldStockLink){if("Default"===bankLinker.state)0===creep.store.getFreeCapacity()?creep.transfer(bank,RESOURCE_ENERGY):bankLinkerShouldStockLink&&bank.store.energy>constants_1.Constants.BANK_LINKER_CAPACITY?(creep.withdraw(bank,RESOURCE_ENERGY),bankLinker.state="EnergyToLink"):link.store.energy>=constants_1.Constants.BANK_LINKER_CAPACITY?creep.withdraw(link,RESOURCE_ENERGY):this.terminalNeedsEnergy(room,transfer)&&bank.store.energy>=constants_1.Constants.BANK_LINKER_CAPACITY?(creep.withdraw(bank,RESOURCE_ENERGY),bankLinker.state="ResourceToTerminal"):null!=transfer?this.tryHandleTransfer(bankLinker,room,creep,bank,transfer):this.cleanTerminalIfNeeded(bankLinker,room,creep);else if("EnergyToTerminal"===bankLinker.state){const terminals=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TERMINAL});1===terminals.length&&creep.transfer(terminals[0],RESOURCE_ENERGY),bankLinker.state="Default"}else if("ResourceToTerminal"===bankLinker.state){const terminal=this.getTerminal(room);let resource=null;if(null!=terminal){const resources=Object.keys(creep.store);for(let i=0;i<resources.length;i++)if(creep.transfer(terminal,resources[i])===OK){resource=resources[i];break}}null!=transfer&&transfer.resource===resource&&(transfer.amountLeft-=constants_1.Constants.BANK_LINKER_CAPACITY),bankLinker.state="Default"}else if("ResourceToBank"===bankLinker.state){let resource=null;if(null!=this.getTerminal(room)){const resources=Object.keys(creep.store);for(let i=0;i<resources.length;i++)if(creep.transfer(bank,resources[i])===OK){resource=resources[i];break}}null!=transfer&&transfer.resource===resource&&(transfer.amountLeft-=constants_1.Constants.BANK_LINKER_CAPACITY),bankLinker.state="Default"}else"EnergyToLink"===bankLinker.state&&(creep.transfer(link,RESOURCE_ENERGY),bankLinker.state="Default")}static cleanTerminalIfNeeded(bankLinker,room,creep){if(0!==Memory.myMemory.empire.transfers.length)return;const terminal=this.getTerminal(room);if(null!=terminal){const resources=Object.keys(terminal.store);for(let i=0;i<resources.length;i++)if("energy"!==resources[i]&&creep.withdraw(terminal,resources[i])===OK){bankLinker.state="ResourceToBank",report_controller_1.ReportController.email("BAD: Creep is cleaning the terminal in "+log_helper_1.LogHelper.roomNameAsLink(room.name),report_cooldown_constants_1.ReportCooldownConstants.HOUR);break}}}static tryHandleTransfer(bankLinker,room,creep,bank,transfer){if("Loading"===transfer.state)creep.withdraw(bank,transfer.resource),bankLinker.state="ResourceToTerminal";else if("Unloading"===transfer.state){const terminal=this.getTerminal(room);null!=terminal&&(creep.withdraw(terminal,transfer.resource),bankLinker.state="ResourceToBank")}}static terminalNeedsEnergy(room,transfer){const terminal=this.getTerminal(room);return null!=terminal&&(null!=transfer&&"energy"===transfer.resource&&transfer.roomFrom===room.name&&"Loading"===transfer.state?terminal.store.getUsedCapacity(RESOURCE_ENERGY)<transfer.amount+constants_1.Constants.TERMINAL_GOAL_ENERGY:terminal.store.getUsedCapacity(RESOURCE_ENERGY)<constants_1.Constants.TERMINAL_GOAL_ENERGY)}static getTerminal(room){const terminals=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TERMINAL});return 1===terminals.length?terminals[0]:null}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomLinkController=void 0;const log_helper_1=__webpack_require__(1),constants_1=__webpack_require__(4),report_controller_1=__webpack_require__(0);exports.RoomLinkController=class{static run(myRoom){if(myRoom.roomStage<4||null==myRoom.bank||null==myRoom.bank.bankLink||null==myRoom.bank.bankLink.id)return!1;let linkControllerNeedsEnergy=!1,controllerLink=null;null!=myRoom.controllerLink&&null!=myRoom.controllerLink.id&&(controllerLink=Game.getObjectById(myRoom.controllerLink.id),null==controllerLink?(report_controller_1.ReportController.email("ERROR: Controller link was null when accessed by ID. Setting it to null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),myRoom.controllerLink.id=null):controllerLink.store.getUsedCapacity(RESOURCE_ENERGY)<constants_1.Constants.LINK_CONTROLLER_GOAL_ENERGY?linkControllerNeedsEnergy=!0:controllerLink=null);for(let i=0;i<myRoom.mySources.length;i++){const mySource=myRoom.mySources[i];null!=mySource.link&&this.runSourceLink(myRoom,mySource.link,controllerLink)&&(controllerLink=null,linkControllerNeedsEnergy=!1)}if(linkControllerNeedsEnergy){const bankLink=Game.getObjectById(myRoom.bank.bankLink.id);null==bankLink?(report_controller_1.ReportController.email("ERROR: Bank link was null when accessed by ID. Setting it to null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),myRoom.bank.bankLink.id=null):bankLink.store.energy>=constants_1.Constants.LINK_TRANSFER_AT&&bankLink.transferEnergy(controllerLink)===OK&&(linkControllerNeedsEnergy=!1)}return linkControllerNeedsEnergy}static runSourceLink(myRoom,myLink,controllerLink){if(null===myLink.id)return!1;if(null==myRoom.bank||null==myRoom.bank.bankLink||null==myRoom.bank.bankLink.id)return!1;const link=Game.getObjectById(myLink.id);if(null===link)return report_controller_1.ReportController.email("ERROR: Link was null when accessed by ID. Setting it to null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),myLink.id=null,!1;if(link.store.energy>=constants_1.Constants.LINK_TRANSFER_AT){if(null!=controllerLink&&link.transferEnergy(controllerLink)===OK)return!0;const bankLink=Game.getObjectById(myRoom.bank.bankLink.id);if(null===bankLink)return report_controller_1.ReportController.email("ERROR: Bank link was null when accessed by ID. Setting it to null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),myRoom.bank.bankLink.id=null,!1;link.transferEnergy(bankLink)}return!1}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleStocker=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7),constants_1=__webpack_require__(4),lab_1=__webpack_require__(66);exports.RoleStocker=class{static run(stocker,myRoom,labOrder){if(creep_helper_1.CreepHelper.handleCreepPreRole(stocker))return;const room=Game.rooms[myRoom.name],creep=Game.creeps[stocker.name];this.calculateCreepState(stocker,room,creep,labOrder,myRoom),"PickupEnergy"===stocker.state?this.pickupResourceFromBank(stocker,myRoom,creep,RESOURCE_ENERGY):"DistributeEnergy"===stocker.state?this.distributeEnergy(stocker,creep):"PickupResources"===stocker.state?this.pickupResources(stocker,creep):"PickupReagents"===stocker.state?this.pickupReagents(stocker,myRoom,creep,labOrder):"DepositReagents"===stocker.state?this.depositReagents(stocker,myRoom,creep,labOrder):"PickupCompounds"===stocker.state?this.pickupCompounds(stocker,myRoom,creep,labOrder):"CleanLabs"===stocker.state?this.cleanLabs(stocker,myRoom,creep):"EnergyToNuker"===stocker.state?this.resourceToNuker(stocker,creep,room,RESOURCE_ENERGY):"DepositResources"===stocker.state?this.depositResources(stocker,myRoom,creep):"PickupG"===stocker.state?this.pickupResourceFromBank(stocker,myRoom,creep,RESOURCE_GHODIUM):"GToNuker"===stocker.state?this.resourceToNuker(stocker,creep,room,RESOURCE_GHODIUM):"PickupPowerSpawnResoures"===stocker.state?this.pickupPowerSpawnResources(stocker,myRoom,creep):"StockPowerSpawn"===stocker.state?this.stockPowerSpawn(stocker,myRoom,creep,room):"CleanPowerSpawn"===stocker.state&&this.cleanPowerSpawn(stocker,myRoom,creep,room)}static calculateCreepState(stocker,room,creep,labOrder,myRoom){let emptyAndNeedNewJob=!1;"DistributeEnergy"===stocker.state?!this.structureNeedsEnergy(room)&&(this.resourcesToPickup(room)||this.labOrderToLoadFor(labOrder)||this.labOrderToUnloadFor(labOrder)||this.canStockPowerSpawn(myRoom,room)||this.canCleanPowerSpawn(myRoom,room))?(stocker.state="DepositResources",creep.say("/ to ")):0===creep.store.getUsedCapacity()&&(stocker.state="PickupEnergy",creep.say(" from ")):"PickupEnergy"===stocker.state?0===creep.store.getFreeCapacity()&&(this.structureNeedsEnergy(room)?(stocker.state="DistributeEnergy",creep.say("Distribute ")):this.nukerNeedsEnergy(myRoom,room)?(stocker.state="EnergyToNuker",creep.say(" to ")):(stocker.state="DepositResources",creep.say("/ to "))):"DepositResources"===stocker.state?0===creep.store.getUsedCapacity()&&(emptyAndNeedNewJob=!0):"PickupResources"===stocker.state?this.resourcesToPickup(room)&&0!==creep.store.getFreeCapacity()||(stocker.state="DepositResources",creep.say("/ to ")):"PickupReagents"===stocker.state?null==labOrder?(stocker.state="DepositResources",creep.say("/ to ")):creep.store.getUsedCapacity(labOrder.reagent1)>0&&creep.store.getUsedCapacity(labOrder.reagent2)>0&&(stocker.state="DepositReagents",creep.say(" to ")):"DepositReagents"===stocker.state?null==labOrder?(stocker.state="DepositResources",creep.say("/ to ")):0===creep.store.getUsedCapacity()&&(emptyAndNeedNewJob=!0):"PickupCompounds"===stocker.state?null!=labOrder&&0!==creep.store.getFreeCapacity()&&this.labOrderToUnloadFor(labOrder)||(stocker.state="DepositResources",creep.say("/ to ")):"CleanLabs"===stocker.state?0!==creep.store.getFreeCapacity()&&this.labsNeedCleaning(myRoom)||(stocker.state="DepositResources",creep.say("/ to ")):"EnergyToNuker"===stocker.state?0!==creep.store.getUsedCapacity()&&this.nukerNeedsEnergy(myRoom,room)||(stocker.state="DepositResources",creep.say("/ to ")):"PickupG"===stocker.state?creep.store.getUsedCapacity(RESOURCE_GHODIUM)>0&&(this.nukerNeedsG(myRoom,room)?(stocker.state="GToNuker",creep.say("G to ")):(stocker.state="DepositResources",creep.say("/ to "))):"GToNuker"===stocker.state?0!==creep.store.getUsedCapacity(RESOURCE_GHODIUM)&&this.nukerNeedsG(myRoom,room)||(stocker.state="DepositResources",creep.say("/ to ")):"PickupPowerSpawnResoures"===stocker.state?creep.store.power>0&&creep.store.energy>0&&(stocker.state="StockPowerSpawn",creep.say("+ to PS")):"StockPowerSpawn"===stocker.state?0===creep.store.getUsedCapacity()&&(emptyAndNeedNewJob=!0):"CleanPowerSpawn"===stocker.state&&(0!==creep.store.getFreeCapacity()&&this.canCleanPowerSpawn(myRoom,room)||(stocker.state="DepositResources",creep.say("+ to "))),emptyAndNeedNewJob&&(null!=creep.ticksToLive&&creep.ticksToLive<constants_1.Constants.SUICIDE_STOCKER_WHEN_TTL_BELOW?creep.suicide():this.structureNeedsEnergy(room)?(stocker.state="PickupEnergy",creep.say(" from ")):this.labOrderToLoadFor(labOrder)?(stocker.state="PickupReagents",creep.say(" from ")):this.labOrderToUnloadFor(labOrder)?(stocker.state="PickupCompounds",creep.say("Pickup ")):this.labsNeedCleaning(myRoom)?(report_controller_1.ReportController.email("BAD: Creep is cleaning the labs in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),stocker.state="CleanLabs",creep.say("CleanLabs")):this.resourcesToPickup(room)?(stocker.state="PickupResources",creep.say(" from ")):this.nukerNeedsEnergy(myRoom,room)?(stocker.state="PickupEnergy",creep.say(" from ")):this.nukerNeedsG(myRoom,room)?(stocker.state="PickupG",creep.say("G from ")):this.canCleanPowerSpawn(myRoom,room)?(report_controller_1.ReportController.email("BAD: Creep is cleaning the power spawn in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),stocker.state="CleanPowerSpawn",creep.say("Clean PS")):this.canStockPowerSpawn(myRoom,room)&&(stocker.state="PickupPowerSpawnResoures",creep.say("+ from ")))}static pickupPowerSpawnResources(stocker,myRoom,creep){if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Room's bank pos was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const capacity=creep.store.getCapacity(),powerWanted=Math.floor(capacity/50)-1,energyWanted=50*powerWanted;let resource=null,amountToGrab=null;if(0===creep.store.energy?(resource=RESOURCE_ENERGY,amountToGrab=energyWanted):0===creep.store.power&&(resource=RESOURCE_POWER,amountToGrab=powerWanted),null==resource||null==amountToGrab)return void report_controller_1.ReportController.email("ERROR: resource/amountToGrab null in stocker logic "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const withdrawResult=creep.withdraw(bank,resource,amountToGrab);withdrawResult!==OK&&report_controller_1.ReportController.email("ERROR: Withdraw reagent "+resource+" for stocker in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" resulted in "+log_helper_1.LogHelper.logScreepsReturnCode(withdrawResult))}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,stocker)}static stockPowerSpawn(stocker,myRoom,creep,room){const powerSpawns=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_SPAWN});if(1!==powerSpawns.length)return;const powerSpawn=powerSpawns[0];if(creep.pos.isNearTo(powerSpawn)){const resources=Object.keys(creep.store);if(resources.length>0){const result=creep.transfer(powerSpawn,resources[0]);result!==OK&&report_controller_1.ReportController.email("ERROR: Bad result from stocking powerspawn, error "+log_helper_1.LogHelper.logScreepsReturnCode(result))}}else movement_helper_1.MovementHelper.myMoveTo(creep,powerSpawn.pos,stocker)}static resourceToNuker(stocker,creep,room,resource){const nuker=this.getNuker(room);null!=nuker&&creep.transfer(nuker,resource)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,nuker.pos,stocker)}static cleanLabs(stocker,myRoom,creep){const lab=lab_1.RoomLabController.getNonBufferLabsThatAreNotEmpty(myRoom);if(null==lab)return;const resources=Object.keys(lab.store);resources.length>0&&creep.withdraw(lab,resources[0])===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,lab.pos,stocker)}static cleanPowerSpawn(stocker,myRoom,creep,room){const powerSpawns=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_SPAWN});if(1!==powerSpawns.length)return;const powerSpawn=powerSpawns[0],resources=Object.keys(powerSpawn.store);resources.length>0&&creep.withdraw(powerSpawn,resources[0])===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,powerSpawn.pos,stocker)}static pickupCompounds(stocker,myRoom,creep,labOrder){const labMemory=myRoom.labs;let moved=!1;for(let i=0;i<labMemory.compoundLabs.length;i++){const compoundLabMemory=labMemory.compoundLabs[i],lab=Game.getObjectById(compoundLabMemory.id);if(null==lab){report_controller_1.ReportController.email("ERROR: A compound lab was null in pickupCompounds in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));continue}if(0===lab.store.getUsedCapacity())continue;const resources=Object.keys(lab.store);if(resources.length>0){const result=creep.withdraw(lab,resources[0]);if(result===OK){if(moved)return void creep.cancelOrder("move")}else result!==ERR_NOT_IN_RANGE||moved||(moved=!0,movement_helper_1.MovementHelper.myMoveTo(creep,lab.pos,stocker))}}}static depositReagents(stocker,myRoom,creep,labOrder){const reagentLab1=Game.getObjectById(myRoom.labs.reagentLab1.id),reagentLab2=Game.getObjectById(myRoom.labs.reagentLab2.id);if(null==reagentLab1||null==reagentLab2)return void report_controller_1.ReportController.email("ERROR: A reagent lab was null in stocker.depositReagents in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const depositingReagent1=2===Object.keys(creep.store).length,targetLab=depositingReagent1?reagentLab1:reagentLab2;if(creep.pos.isNearTo(targetLab)){const resourceToDeposit=depositingReagent1?labOrder.reagent1:labOrder.reagent2;creep.transfer(targetLab,resourceToDeposit),depositingReagent1||(labOrder.amountLeftToLoad-=creep.store.getUsedCapacity(resourceToDeposit))}else movement_helper_1.MovementHelper.myMoveTo(creep,targetLab.pos,stocker)}static pickupReagents(stocker,myRoom,creep,labOrder){if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Room's bank pos was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));let amountToGrab=labOrder.amountLeftToLoad;2*amountToGrab>creep.store.getCapacity()&&(amountToGrab=creep.store.getCapacity()/2);const resourceToGrab=creep.store.getUsedCapacity()>0?labOrder.reagent2:labOrder.reagent1,withdrawResult=creep.withdraw(bank,resourceToGrab,amountToGrab);withdrawResult!==OK&&report_controller_1.ReportController.log("ERROR: Withdraw reagent "+resourceToGrab+" for stocker in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" resulted in "+withdrawResult)}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,stocker)}static pickupResourceFromBank(stocker,myRoom,creep,resource){if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Room's bank pos was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));bank.store.getUsedCapacity(resource)>0&&creep.withdraw(bank,resource)}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,stocker)}static distributeEnergy(stocker,creep){let structureToAddTo=creep.pos.findClosestByPath(FIND_STRUCTURES,{filter:structure=>(structure.structureType===STRUCTURE_EXTENSION||structure.structureType===STRUCTURE_SPAWN)&&structure.energy<structure.energyCapacity});null==structureToAddTo&&(structureToAddTo=creep.pos.findClosestByPath(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_TOWER&&structure.energy<constants_1.Constants.STOCK_TOWER_TO}),null==structureToAddTo)||creep.transfer(structureToAddTo,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,structureToAddTo.pos,stocker)}static pickupResources(stocker,creep){const resource=creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES);if(null!=resource)return void(creep.pos.isNearTo(resource.pos)?creep.pickup(resource):movement_helper_1.MovementHelper.myMoveTo(creep,resource.pos,stocker));const tombstone=creep.pos.findClosestByPath(FIND_TOMBSTONES,{filter:t=>t.store.getUsedCapacity()>0});if(null==tombstone);else if(creep.pos.isNearTo(tombstone.pos)){const resourcesInTombstone=Object.keys(tombstone.store);for(let i=0;i<resourcesInTombstone.length;i++)creep.withdraw(tombstone,resourcesInTombstone[i])}else movement_helper_1.MovementHelper.myMoveTo(creep,tombstone.pos,stocker)}static depositResources(stocker,myRoom,creep){if(null==myRoom.bank||null==myRoom.bank.bankPos)return void report_controller_1.ReportController.email("ERROR: Room's bank pos was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const resources=Object.keys(creep.store);for(let i=0;i<resources.length&&creep.transfer(bank,resources[i])!==OK;i++);}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,stocker)}static structureNeedsEnergy(room){return room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType!==STRUCTURE_TOWER?(structure.structureType===STRUCTURE_EXTENSION||structure.structureType===STRUCTURE_SPAWN)&&structure.energy<structure.energyCapacity:structure.energy<constants_1.Constants.STOCK_TOWER_TO}).length>0}static resourcesToPickup(room){return room.find(FIND_TOMBSTONES,{filter:t=>t.store.getUsedCapacity()>0}).length>0||room.find(FIND_DROPPED_RESOURCES).length>0}static labOrderToLoadFor(labOrder){return null!=labOrder&&("InitialLoading"===labOrder.state||"Loading"===labOrder.state)}static labOrderToUnloadFor(labOrder){return null!=labOrder&&"Unloading"===labOrder.state}static labsNeedCleaning(myRoom){if(null==myRoom.labs)return!1;for(let i=0;i<myRoom.labs.labOrders.length;i++)if("Queued"!==myRoom.labs.labOrders[i].state)return!1;return null!=lab_1.RoomLabController.getNonBufferLabsThatAreNotEmpty(myRoom)}static nukerNeedsEnergy(myRoom,room){if(null==myRoom.bank||null==myRoom.bank.object)return report_controller_1.ReportController.email("ERROR: Room's bank object was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),!1;if("NeedsEnergy"!==myRoom.nukerStatus)return!1;const nuker=this.getNuker(room);return null!=nuker&&0!==nuker.store.getFreeCapacity(RESOURCE_ENERGY)&&!(myRoom.bank.object.store.getUsedCapacity(RESOURCE_ENERGY)<constants_1.Constants.DONT_STOCK_NUKER_IF_ENERGY_UNDER)}static canCleanPowerSpawn(myRoom,room){if(null==myRoom.powerSpawn||null==myRoom.bank||null==myRoom.bank.object)return!1;const powerSpawns=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_SPAWN});if(1!==powerSpawns.length)return!1;const powerSpawn=powerSpawns[0];return powerSpawn.store.energy!==50*powerSpawn.store.power}static canStockPowerSpawn(myRoom,room){if(null==myRoom.powerSpawn||"Good"===myRoom.powerSpawn.resources||null==myRoom.bank||null==myRoom.bank.object)return!1;const powerSpawns=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_SPAWN});if(1!==powerSpawns.length)return!1;const powerSpawn=powerSpawns[0];return!(powerSpawn.store.energy>constants_1.Constants.POWER_SPAWN_RESTOCK_WHEN_ENERGY_BELOW||powerSpawn.store.power>constants_1.Constants.POWER_SPAWN_RESTOCK_WHEN_ENERGY_BELOW/50)&&!(myRoom.bank.object.store.power<24||myRoom.bank.object.store.energy<constants_1.Constants.POWER_SPAWN_MIN_ENERGY)}static nukerNeedsG(myRoom,room){if(null==myRoom.bank||null==myRoom.bank.object)return report_controller_1.ReportController.email("ERROR: Room's bank object was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),!1;if("NeedsG"!==myRoom.nukerStatus)return!1;const nuker=this.getNuker(room);return null!=nuker&&0!==nuker.store.getFreeCapacity(RESOURCE_GHODIUM)&&!(myRoom.bank.object.store.getUsedCapacity(RESOURCE_GHODIUM)<1250)}static getNuker(room){const nukers=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_NUKER});return 1!==nukers.length?null:nukers[0]}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomLabController=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),constants_1=__webpack_require__(4);exports.RoomLabController=class{static run(myRoom){const labOrder=this.getLabOrder(myRoom);if(null!=labOrder){const labMemory=myRoom.labs;if(("Loading"===labOrder.state||"Running"===labOrder.state)&&this.runReactions(labMemory,labOrder,myRoom.name))return this.removeLabOrder(labMemory,labOrder),null;this.updateLabOrder(myRoom,labOrder)&&this.removeLabOrder(labMemory,labOrder)}return labOrder}static getNonBufferLabsThatAreNotEmpty(myRoom){if(null==myRoom.labs)return null;const labs=Game.rooms[myRoom.name].find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_LAB});for(let i=0;i<labs.length;i++){const lab=labs[i];if(lab.id!==myRoom.labs.buffingLab&&0!==lab.store.getUsedCapacity())return lab}return null}static runReactions(labMemory,labOrder,roomName){if(Game.cpu.bucket<constants_1.Constants.DONT_RUN_REACTIONS_WHEN_BUCKET_UNDER)return report_controller_1.ReportController.log("Not running reactions because bucket is "+Game.cpu.bucket),!1;const reagentLab1=Game.getObjectById(labMemory.reagentLab1.id),reagentLab2=Game.getObjectById(labMemory.reagentLab2.id);if(null==reagentLab1||null==reagentLab2)return report_controller_1.ReportController.email("ERROR: A reagent lab was null in runReactions in "+log_helper_1.LogHelper.roomNameAsLink(roomName)),!1;for(let i=0;i<labMemory.compoundLabs.length;i++){const compoundLabMemory=labMemory.compoundLabs[i];if(labOrder.cooldownTill>Game.time)continue;const lab=Game.getObjectById(compoundLabMemory.id);if(null==lab){report_controller_1.ReportController.email("ERROR: A compound lab was null in runReactions in "+log_helper_1.LogHelper.roomNameAsLink(roomName));continue}const result=lab.runReaction(reagentLab1,reagentLab2);if(result===OK)labOrder.cooldownTill=Game.time+labOrder.cooldown;else{if(0===labOrder.amountLeftToLoad&&result===ERR_NOT_ENOUGH_RESOURCES)return report_controller_1.ReportController.email("ERROR: Running reaction got 'ERR_NOT_ENOUGH_RESOURCES', but amountLeftToLoad === 0 in "+log_helper_1.LogHelper.roomNameAsLink(roomName)+", removing lab order"),!0;report_controller_1.ReportController.log("BAD: Bad result for runReaction, in "+log_helper_1.LogHelper.roomNameAsLink(roomName)+" result:"+log_helper_1.LogHelper.logScreepsReturnCode(result))}}return!1}static updateLabOrder(myRoom,labOrder){const labMemory=myRoom.labs,reagentLab1=Game.getObjectById(labMemory.reagentLab1.id),reagentLab2=Game.getObjectById(labMemory.reagentLab2.id);if(null==reagentLab1||null==reagentLab2)return report_controller_1.ReportController.email("ERROR: A reagent lab was null in updateLabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),!1;if("InitialLoading"===labOrder.state)reagentLab1.store[labOrder.reagent1]>0&&reagentLab2.store[labOrder.reagent2]>0&&(labOrder.state="Loading",report_controller_1.ReportController.log("LabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+": InitialLoading -> Loading"));else if("Loading"===labOrder.state)0===labOrder.amountLeftToLoad&&(labOrder.state="Running",report_controller_1.ReportController.log("LabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+": Loading -> Running"));else if("Running"===labOrder.state)0===reagentLab1.store[labOrder.reagent1]&&0===reagentLab2.store[labOrder.reagent2]&&(labOrder.state="Unloading",report_controller_1.ReportController.log("LabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+": Running -> Unloading"));else if("Unloading"===labOrder.state){for(let i=0;i<labMemory.compoundLabs.length;i++){const compoundLabMemory=labMemory.compoundLabs[i],lab=Game.getObjectById(compoundLabMemory.id);if(null==lab)return report_controller_1.ReportController.email("ERROR: A compound lab was null in updateLabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)),!1;if(0!==lab.store.getUsedCapacity())return!1}return report_controller_1.ReportController.log("LabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+": Unloading -> Completed"),!0}return!1}static getLabOrder(myRoom){if(null==myRoom.labs||0===myRoom.labs.labOrders.length)return null;for(let i=0;i<myRoom.labs.labOrders.length;i++){const labOrder=myRoom.labs.labOrders[i];if("Queued"!==labOrder.state)return labOrder}if(null!=this.getNonBufferLabsThatAreNotEmpty(myRoom))return null;const bank=myRoom.bank.object;for(let i=0;i<myRoom.labs.labOrders.length;i++){const labOrder=myRoom.labs.labOrders[i];if(bank.store[labOrder.reagent1]>=labOrder.amount&&bank.store[labOrder.reagent2]>=labOrder.amount){const lab=Game.getObjectById(myRoom.labs.compoundLabs[0].id);return null!=lab.cooldown&&lab.cooldown>0&&(lab.cooldown=Game.time+lab.cooldown),report_controller_1.ReportController.log("LabOrder in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+": Queued -> InitialLoading"),labOrder.state="InitialLoading",labOrder}report_controller_1.ReportController.email("BAD: Not enough resources for lab order "+labOrder.compound+" in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+", removing lab order"),this.removeLabOrder(myRoom.labs,labOrder)}return null}static removeLabOrder(labMemory,labOrder){for(let i=labMemory.labOrders.length-1;i>=0;i--)labMemory.labOrders[i].state===labOrder.state&&labMemory.labOrders[i].compound===labOrder.compound&&labMemory.labOrders.splice(i,1)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomDefenseController=void 0;const report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),log_helper_1=__webpack_require__(1);exports.RoomDefenseController=class{static run(myRoom,room){if(Game.time%100!=0)return;const nukes=room.find(FIND_NUKES);if(nukes.length>0){const landingTime=Game.time+nukes[0].timeToLand;report_controller_1.ReportController.email("NUKE DETECTED in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" will land in tick: "+landingTime,report_cooldown_constants_1.ReportCooldownConstants.DAY)}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomNukerController=void 0;const flag_helper_1=__webpack_require__(9),report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1);exports.RoomNukerController=class{static run(myRoom,room){this.determineNukerStatus(myRoom,room)}static checkForNukeLaunchFlags(myRooms){if(Game.time%10!=0||null!=Game.flags["nuke-hold"])return;const nukeTargets=flag_helper_1.FlagHelper.getFlags3(["nuke","launch"]);if(0===nukeTargets.length)return;const readyNukers=[];for(let i=0;i<myRooms.length;i++){const myRoom=myRooms[i];if("Full"!==myRoom.nukerStatus)continue;const room=Game.rooms[myRoom.name],nuker=this.getNuker(room);null==nuker||0!==nuker.store.getFreeCapacity(RESOURCE_ENERGY)||0!==nuker.store.getFreeCapacity(RESOURCE_GHODIUM)||null!=nuker.cooldown&&nuker.cooldown>=1||readyNukers.push(nuker)}if(nukeTargets.length>readyNukers.length)return void report_controller_1.ReportController.log("Nuking aborted: Too many nukeTargets ("+nukeTargets.length+") for the amount of loaded ready nukers ("+readyNukers.length+")");const nukerWithTargetArray=[];for(let i=0;i<nukeTargets.length;i++){const target=nukeTargets[i];let foundNuker=!1;for(let j=0;j<readyNukers.length;j++){const nuker=readyNukers[i];let nukerBeenTakenByPreviousTarget=!1;for(let k=0;k<nukerWithTargetArray.length;k++)if(nukerWithTargetArray[k].nuker.id===nuker.id){nukerBeenTakenByPreviousTarget=!0;break}if(!nukerBeenTakenByPreviousTarget&&!(Game.map.getRoomLinearDistance(nuker.pos.roomName,target.pos.roomName)>10)){nukerWithTargetArray.push({target:target,nuker:nuker}),foundNuker=!0;break}}if(!foundNuker)return void report_controller_1.ReportController.log("Nuking aborted: Wasn't able to find a nuker for target "+log_helper_1.LogHelper.logPos(target.pos)+" in room "+log_helper_1.LogHelper.roomNameAsLink(target.pos.roomName))}if(nukerWithTargetArray.length===nukeTargets.length)for(let i=0;i<nukerWithTargetArray.length;i++){const nukerWithTarget=nukerWithTargetArray[i],targetPos=nukerWithTarget.target.pos;nukerWithTarget.target.remove();const result=nukerWithTarget.nuker.launchNuke(targetPos);result!==OK?report_controller_1.ReportController.log("Bad nuke launch result "+log_helper_1.LogHelper.logScreepsReturnCode(result)):report_controller_1.ReportController.log("Nuke launch: Succesfully launched nuke for "+log_helper_1.LogHelper.logPos(targetPos)+" in room "+log_helper_1.LogHelper.roomNameAsLink(targetPos.roomName))}else report_controller_1.ReportController.log("Nuking aborted: nukerWithTargetArray.length !== nukeTargets.length, "+nukerWithTargetArray.length+" !== "+nukeTargets.length)}static determineNukerStatus(myRoom,room){if(Game.time%100!=0)return;const nukers=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_NUKER});if(1!==nukers.length)return void(myRoom.nukerStatus=null);const nuker=nukers[0];nuker.store.getFreeCapacity(RESOURCE_ENERGY)>0?myRoom.nukerStatus="NeedsEnergy":nuker.store.getFreeCapacity(RESOURCE_GHODIUM)>0?myRoom.nukerStatus="NeedsG":("Full"!==myRoom.nukerStatus&&report_controller_1.ReportController.email("Nuker in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" is now full"),myRoom.nukerStatus="Full")}static getNuker(room){const nukers=room.find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_NUKER});return 1!==nukers.length?null:nukers[0]}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EmpireController=void 0;const claimer_1=__webpack_require__(70),spawn_claimer_controller_1=__webpack_require__(17),attack_controller_1=__webpack_require__(71),build_observer_controller_1=__webpack_require__(75),observer_controller_1=__webpack_require__(76),power_bank_controller_1=__webpack_require__(14),sign_controller_1=__webpack_require__(77),scavenge_controller_1=__webpack_require__(13),scavenger_1=__webpack_require__(78),mineral_controller_1=__webpack_require__(89),nuker_1=__webpack_require__(68),legolas_1=__webpack_require__(91);exports.EmpireController=class{static run(myMemory){this.oddThousandLogic(myMemory),spawn_claimer_controller_1.SpawnClaimerController.run(myMemory),attack_controller_1.AttackController.run(myMemory),build_observer_controller_1.BuildObserverController.run(),observer_controller_1.ObserverController.run(myMemory),sign_controller_1.SignController.run(myMemory),mineral_controller_1.MineralController.run(myMemory),power_bank_controller_1.PowerBankController.run(myMemory.empire.powerBanks),scavenge_controller_1.ScavengeController.run(myMemory),nuker_1.RoomNukerController.checkForNukeLaunchFlags(myMemory.myRooms);for(let i=0;i<myMemory.empire.creeps.length;i++){const creep=myMemory.empire.creeps[i];"Claimer"===creep.role?claimer_1.RoleClaimer.run(creep):"Scavenger"===creep.role?scavenger_1.RoleScavenger.run(creep):"Signer"===creep.role?sign_controller_1.SignController.runCreep(creep):"Legolas"===creep.role&&legolas_1.RoleLegolas.run(creep)}}static oddThousandLogic(myMemory){Game.time%1e3==0&&(myMemory.empire.oddThousand=!myMemory.empire.oddThousand)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleClaimer=void 0;const report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),movement_helper_1=__webpack_require__(7),log_helper_1=__webpack_require__(1);exports.RoleClaimer=class{static run(claimer){const creep=Game.creeps[claimer.name];if(creep_helper_1.CreepHelper.handleCreepPreRole(claimer))return;if(null==Game.flags[claimer.flagName])return creep.say("dthb4dshnr"),void creep.suicide();null!=creep.room.controller?creep.claimController(creep.room.controller)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,creep.room.controller.pos,claimer):report_controller_1.ReportController.email("ERROR: Claimer can't claim a room with no controller in "+log_helper_1.LogHelper.roomNameAsLink(creep.room.name))}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AttackController=void 0;const attack_quick_controller_1=__webpack_require__(72),attack_pressure_controller_1=__webpack_require__(73),attack_healer_drain_controller_1=__webpack_require__(74);exports.AttackController=class{static run(myMemory){const attackQuick=myMemory.empire.attackQuick;if(null==attackQuick){const flag=Game.flags["attack-quick-rally"];null!=flag&&(myMemory.empire.attackQuick=attack_quick_controller_1.AttackQuickController.setupAttackQuick(myMemory.myRooms,flag))}null!=attackQuick&&attack_quick_controller_1.AttackQuickController.run(myMemory,attackQuick);const attackPressure=myMemory.empire.attackPressure;if(null==attackPressure){const flag=Game.flags["attack-pressure-rally"];null!=flag&&(myMemory.empire.attackPressure=attack_pressure_controller_1.AttackPressureController.setupAttackPressure(myMemory.myRooms,flag))}null!=attackPressure&&attack_pressure_controller_1.AttackPressureController.run(myMemory,attackPressure);const attackHealerDrain=myMemory.empire.attackHealerDrain;if(null==attackHealerDrain){const flag=Game.flags["attack-healer-drain-rally"];null!=flag&&(myMemory.empire.attackHealerDrain=attack_healer_drain_controller_1.AttackHealerDrainController.setupAttackHealerDrain(myMemory.myRooms,flag))}null!=attackHealerDrain&&attack_healer_drain_controller_1.AttackHealerDrainController.run(myMemory,attackHealerDrain)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AttackQuickController=void 0;const report_controller_1=__webpack_require__(0),constants_1=__webpack_require__(4),attack_helper_functions_1=__webpack_require__(12),attack_creep_1=__webpack_require__(18),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2),map_helper_1=__webpack_require__(11);exports.AttackQuickController=class{static run(myMemory,attackQuick){let flag=null;if("Conscripting"===attackQuick.state){if(flag=Game.flags["attack-quick-rally"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-quick-rally flag doesn't exist during AttackQuick. Cancelling the attack."),void this.endAttack();for(let i=attackQuick.roomsStillToProvide.length-1;i>=0;i--){const myRoom=room_helper_1.RoomHelper.getMyRoomByName(attackQuick.roomsStillToProvide[i]),attackQuickCreep=this.spawnAttackQuickCreep(myRoom,flag.pos.roomName);report_controller_1.ReportController.log(log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" has been conscripted "+attackQuickCreep.name+" for AttackQuick"),myMemory.empire.creeps.push(attackQuickCreep),attackQuick.roomsStillToProvide.splice(i,1)}if(0===attackQuick.roomsStillToProvide.length)return void(attackQuick.state="Rally")}if("Rally"===attackQuick.state){if(flag=Game.flags["attack-quick-rally"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-quick-rally flag doesn't exist during AttackQuick. Cancelling the attack."),void this.endAttack();let allCreepsAtFlag=!0;for(let i=0;i<myMemory.empire.creeps.length;i++){const myCreep=myMemory.empire.creeps[i];if("AttackQuickCreep"!==myCreep.role)continue;const creep=Game.creeps[myCreep.name];if(null==creep||!creep.pos.inRangeTo(flag.pos,constants_1.Constants.RALLY_FLAG_RANGE)){allCreepsAtFlag=!1;break}}if(allCreepsAtFlag){if(null!=Game.flags["attack-hold"])return;report_controller_1.ReportController.log("AttackQuick Charge"),attackQuick.state="Charge";const roomTagetFlag=Game.flags["attack-quick-room-target"];if(null==roomTagetFlag)return report_controller_1.ReportController.email("ERROR: attack-quick-room-target flag doesn't exist during AttackQuick. Cancelling the attack. (1)"),void this.endAttack();for(let i=0;i<myMemory.empire.creeps.length;i++){const myCreep=myMemory.empire.creeps[i];"AttackQuickCreep"===myCreep.role&&(myCreep.assignedRoomName=roomTagetFlag.pos.roomName)}}}if("Charge"===attackQuick.state){if(flag=Game.flags["attack-quick-room-target"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-quick-room-target flag doesn't exist during AttackQuick. Cancelling the attack. (2)"),void this.endAttack();0===myMemory.empire.creeps.length&&(report_controller_1.ReportController.log("ATTACK: Creeps are all dead, ending attack"),this.endAttack()),attackQuick.attackTarget=attack_helper_functions_1.AttackHelperFunctions.getNewTargetIfNeeded(attackQuick.attackTarget,flag)}for(let i=0;i<myMemory.empire.creeps.length;i++){const attackQuickCreep=myMemory.empire.creeps[i];"AttackQuickCreep"===attackQuickCreep.role&&attack_creep_1.RoleAttackCreep.run(attackQuickCreep,attackQuick.state,flag,attackQuick.attackTarget)}null!=attackQuick.attackTarget&&delete attackQuick.attackTarget.roomObject}static setupAttackQuick(myRooms,rallyFlag){const attackQuick={state:"Conscripting",roomsStillToProvide:[],attackTarget:null};let outputMessage="";for(let i=0;i<myRooms.length;i++){const myRoom=myRooms[i];myRoom.roomStage>=constants_1.Constants.CONSCRIPTION_QUICK_MINIMUM_STAGE&&map_helper_1.MapHelper.getRoomDistance(rallyFlag.pos.roomName,myRoom.name)<constants_1.Constants.CONSCRIPTION_RANGE&&(attackQuick.roomsStillToProvide.push(myRoom.name),outputMessage+=log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+", ")}return 0===attackQuick.roomsStillToProvide.length?(report_controller_1.ReportController.log("Canceling an AttackQuick because no rooms were in conscription range."),this.endAttack(),null):(outputMessage=outputMessage.slice(0,outputMessage.length-2),report_controller_1.ReportController.log("AttackQuick: "+attackQuick.roomsStillToProvide.length+" Rooms conscripted for AttackQuick ("+outputMessage+")"),attackQuick)}static spawnAttackQuickCreep(myRoom,rallyRoomName){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.ATTACK_QUICK,name,"AttackQuickCreep"),{name:name,role:"AttackQuickCreep",spawningStatus:"queued",assignedRoomName:rallyRoomName,roomMoveTarget:{pos:null,path:[]}}}static endAttack(){const empire=Memory.myMemory.empire;empire.attackQuick=null;for(let i=empire.creeps.length-1;i>=0;i--)"AttackQuickCreep"===empire.creeps[i].role&&(report_controller_1.ReportController.log("Killing AttackQuickCreep "+empire.creeps[i].name),Game.creeps[empire.creeps[i].name].suicide());attack_helper_functions_1.AttackHelperFunctions.endAttack()}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AttackPressureController=void 0;const constants_1=__webpack_require__(4),report_controller_1=__webpack_require__(0),attack_helper_functions_1=__webpack_require__(12),attack_creep_1=__webpack_require__(18),spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),map_helper_1=__webpack_require__(11),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2),creep_helper_1=__webpack_require__(3);exports.AttackPressureController=class{static run(myMemory,attackPressure){let updatedTarget=!1;const attackPressureCreeps=[];for(let i=0;i<myMemory.empire.creeps.length;i++){const creep=myMemory.empire.creeps[i];"AttackPressureCreep"===creep.role&&attackPressureCreeps.push(creep)}for(let i=attackPressure.batches.length-1;i>=0;i--){let flag=null;const batch=attackPressure.batches[i];if("Conscripting"===batch.state){if(flag=Game.flags["attack-pressure-rally"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-pressure-rally flag doesn't exist during AttackPressure. Cancelling the attack."),void this.endAttack();this.batchRunConscript(batch,myMemory.empire,flag.pos.roomName)}if("Rally"===batch.state){if(flag=Game.flags["attack-pressure-rally"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-pressure-rally flag doesn't exist during AttackPressure. Cancelling the attack."),void this.endAttack();this.batchRunRally(batch,flag,myMemory.empire)&&this.startBatch(attackPressure)}if("Charge"===batch.state){if(flag=Game.flags["attack-pressure-room-target"],null==flag)return report_controller_1.ReportController.email("ERROR: attack-pressure-room-target flag doesn't exist during AttackPressure. Cancelling the attack. (1)"),void this.endAttack();updatedTarget||(updatedTarget=!0,attackPressure.attackTarget=attack_helper_functions_1.AttackHelperFunctions.getNewTargetIfNeeded(attackPressure.attackTarget,flag))}for(let j=0;j<attackPressureCreeps.length;j++)attackPressureCreeps[j].batchNumber===batch.batchNumber&&attack_creep_1.RoleAttackCreep.run(attackPressureCreeps[j],batch.state,flag,attackPressure.attackTarget)}null!=attackPressure.attackTarget&&delete attackPressure.attackTarget.roomObject}static setupAttackPressure(myRooms,rallyFlag){const attackPressure={batchesStarted:0,batches:[],roomsInRange:[],attackTarget:null};let outputMessage="";for(let i=0;i<myRooms.length;i++){const myRoom=myRooms[i];myRoom.roomStage>=constants_1.Constants.CONSCRIPTION_PRESSURE_MINIMUM_STAGE&&map_helper_1.MapHelper.getRoomDistance(rallyFlag.pos.roomName,myRoom.name)<constants_1.Constants.CONSCRIPTION_RANGE&&(attackPressure.roomsInRange.push(myRoom.name),outputMessage+=log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+", ")}return 0===attackPressure.roomsInRange.length?(report_controller_1.ReportController.log("Canceling an AttackPressure because no rooms were in conscription range."),this.endAttack(),null):(outputMessage=outputMessage.slice(0,outputMessage.length-2),report_controller_1.ReportController.log("AttackPressure: "+attackPressure.roomsInRange.length+" Rooms conscripted for AttackPressure ("+outputMessage+")"),this.startBatch(attackPressure),attackPressure)}static batchRunRally(batch,flag,empire){let allCreepsAtFlag=!0;for(let i=0;i<empire.creeps.length;i++){const myCreep=empire.creeps[i];if("AttackPressureCreep"!==myCreep.role||myCreep.batchNumber!==batch.batchNumber)continue;const creep=Game.creeps[myCreep.name];if(null==creep||!creep.pos.inRangeTo(flag.pos,constants_1.Constants.RALLY_FLAG_RANGE)){allCreepsAtFlag=!1;break}}if(allCreepsAtFlag){if(null!=Game.flags["attack-hold"])return!1;report_controller_1.ReportController.log("AttackPressure Charge"),batch.state="Charge";const roomTagetFlag=Game.flags["attack-pressure-room-target"];if(null==roomTagetFlag)return report_controller_1.ReportController.email("ERROR: attack-pressure-room-target flag doesn't exist during AttackPressure. Cancelling the attack. (2)"),this.endAttack(),!1;for(let i=0;i<empire.creeps.length;i++){const myCreep=empire.creeps[i];"AttackPressureCreep"===myCreep.role&&myCreep.batchNumber===batch.batchNumber&&(myCreep.assignedRoomName=roomTagetFlag.pos.roomName)}return!0}return!1}static batchRunConscript(batch,empire,rallyRoomName){for(let i=batch.roomsStillToProvide.length-1;i>=0;i--){const myRoom=room_helper_1.RoomHelper.getMyRoomByName(batch.roomsStillToProvide[i]),attackPressureCreep=this.spawnAttackPressureCreep(myRoom,batch.batchNumber,rallyRoomName);report_controller_1.ReportController.log(log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" has been conscripted "+attackPressureCreep.name+" for AttackPressure"),empire.creeps.push(attackPressureCreep),batch.roomsStillToProvide.splice(i,1)}0!==batch.roomsStillToProvide.length||(batch.state="Rally")}static spawnAttackPressureCreep(myRoom,batchNumber,rallyRoomName){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.ATTACK_PRESSURE,name,"AttackPressureCreep"),{name:name,role:"AttackPressureCreep",spawningStatus:"queued",assignedRoomName:rallyRoomName,roomMoveTarget:{pos:null,path:[]},batchNumber:batchNumber}}static startBatch(attackPressure){attackPressure.batches.push({state:"Conscripting",batchNumber:attackPressure.batchesStarted,roomsStillToProvide:attackPressure.roomsInRange}),report_controller_1.ReportController.log("Conscripting for batch "+attackPressure.batchesStarted),attackPressure.batchesStarted++}static endAttack(){const empire=Memory.myMemory.empire;empire.attackPressure=null;for(let i=empire.creeps.length-1;i>=0;i--)if("AttackPressureCreep"===empire.creeps[i].role){null!=Game.creeps[empire.creeps[i].name]&&(report_controller_1.ReportController.log("Killing AttackPressureCreep "+empire.creeps[i].name),Game.creeps[empire.creeps[i].name].suicide())}attack_helper_functions_1.AttackHelperFunctions.endAttack()}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AttackHealerDrainController=void 0;exports.AttackHealerDrainController=class{static run(myMemory,attackQuick){}static setupAttackHealerDrain(myRooms,rallyFlag){return null}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BuildObserverController=void 0;const report_controller_1=__webpack_require__(0);exports.BuildObserverController=class{static run(){if(Game.time%10!=0)return;const flag=Game.flags.observer;if(null==flag)return;const result=flag.pos.createConstructionSite(STRUCTURE_OBSERVER);result===OK?flag.remove():report_controller_1.ReportController.email("ERROR: Failed to place observer: "+result)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ObserverController=void 0;const power_bank_controller_1=__webpack_require__(14),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),map_helper_1=__webpack_require__(11),log_helper_1=__webpack_require__(1),room_helper_1=__webpack_require__(2);exports.ObserverController=class{static run(myMemory){this.generateTargetsIfNeeded(myMemory)||null!=myMemory.empire.observer&&this.observeLogic(myMemory)}static observe(room,myMemory){const empireMemory=myMemory.empire;let avoid=!1;if(null!=room.controller&&!1===room.controller.my&&null!=room.controller.owner?room.controller.level>=3?avoid=!0:report_controller_1.ReportController.email("Scrubs in your local area want to get wrecked "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" Owner: "+room.controller.owner.username+" Safemode: "+(null!=room.controller.safeMode),report_cooldown_constants_1.ReportCooldownConstants.DAY):map_helper_1.MapHelper.isMiddle3x3(room.name)&&(avoid=!0),avoid)empireMemory.avoidRooms.includes(room.name)||(report_controller_1.ReportController.email("Added "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" to avoid list",report_cooldown_constants_1.ReportCooldownConstants.DAY),empireMemory.avoidRooms.push(room.name));else if(empireMemory.avoidRooms.includes(room.name)&&(report_controller_1.ReportController.email("Removing "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" from avoid list",report_cooldown_constants_1.ReportCooldownConstants.DAY),empireMemory.avoidRooms.splice(empireMemory.avoidRooms.indexOf(room.name),1)),map_helper_1.MapHelper.isHighway(room.name)){const powerBanks=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_BANK});1===powerBanks.length&&power_bank_controller_1.PowerBankController.observedPowerBank(powerBanks[0])}}static observeLogic(myMemory){const observerMemory=myMemory.empire.observer;if(null==observerMemory)return;const room=Game.rooms[observerMemory.currentObservingRoomName];null==room?report_controller_1.ReportController.log("ERROR: Room from observer was null "+log_helper_1.LogHelper.roomNameAsLink(observerMemory.currentObservingRoomName)):this.observe(room,myMemory),observerMemory.nextObservingRoom.xNum++,observerMemory.nextObservingRoom.xNum>observerMemory.topLeftX+observerMemory.size&&(observerMemory.nextObservingRoom.xNum=observerMemory.topLeftX,observerMemory.nextObservingRoom.yNum++,observerMemory.nextObservingRoom.yNum>observerMemory.topLeftY+observerMemory.size&&(observerMemory.nextObservingRoom.yNum=observerMemory.topLeftY)),observerMemory.currentObservingRoomName=room_helper_1.RoomHelper.getRoomNameAsString(observerMemory.nextObservingRoom);const observer=Game.getObjectById(observerMemory.observerId);null!=observer?observer.observeRoom(observerMemory.currentObservingRoomName):(report_controller_1.ReportController.email("ERROR: Observer was null. Stopping observers"),myMemory.empire.observer=null)}static generateTargetsIfNeeded(myMemory){if(Game.time%10!=0)return!1;const flagNames=Object.keys(Game.flags);for(let i=flagNames.length-1;i>=0;i--){const flagNameSplit=flagNames[i].split("-");"observer"===flagNameSplit[0]&&"set"===flagNameSplit[1]||flagNames.splice(i,1)}if(1!==flagNames.length)return!1;const flag=Game.flags[flagNames[0]],size=Number(flag.name.split("-")[2]),topLeftRoomName=room_helper_1.RoomHelper.getRoomNameAsInterface(flag.pos.roomName);let observer=null;for(let i=0;i<myMemory.myRooms.length;i++){const observers=Game.rooms[myMemory.myRooms[i].name].find(FIND_MY_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_OBSERVER});observers.length>=1&&(observer=observers[0])}if(null==observer)return flag.remove(),!1;const topLeftRoomNameAsString=room_helper_1.RoomHelper.getRoomNameAsString(topLeftRoomName);return null==myMemory.empire.observer&&(myMemory.empire.observer={nextObservingRoom:topLeftRoomName,currentObservingRoomName:topLeftRoomNameAsString,observerId:observer.id,size:size,topLeftX:topLeftRoomName.xNum,topLeftY:topLeftRoomName.yNum}),observer.observeRoom(topLeftRoomNameAsString),report_controller_1.ReportController.log("Observer set with size "+size+", rooms: "+size*size),flag.remove(),!0}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SignController=void 0;const spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),report_controller_1=__webpack_require__(0),creep_helper_1=__webpack_require__(3),movement_helper_1=__webpack_require__(7),log_helper_1=__webpack_require__(1),map_helper_1=__webpack_require__(11);class SignController{static run(myMemory){if(Game.time%100!=0)return;const flag=Game.flags.sign;if(null!=flag)return void this.sign(flag,myMemory);const flagAll=Game.flags["sign-all"];null!=flagAll&&this.signAll(flagAll,myMemory)}static runCreep(signer){const creep=Game.creeps[signer.name];if(creep_helper_1.CreepHelper.handleCreepPreRole(signer))return;if(null==creep.room.controller)return void report_controller_1.ReportController.email("ERROR: Signer can't sign a room with no controller in "+log_helper_1.LogHelper.roomNameAsLink(creep.room.name));const signResult=creep.signController(creep.room.controller,signer.signWords);signResult===ERR_NOT_IN_RANGE?movement_helper_1.MovementHelper.myMoveTo(creep,creep.room.controller.pos,signer):signResult===OK&&(report_controller_1.ReportController.log("Successfully signed "+log_helper_1.LogHelper.roomNameAsLink(signer.assignedRoomName)),creep.say("dthb4dshnr"),creep.suicide())}static signAll(flag,myMemory){for(let i=0;i<myMemory.myRooms.length;i++){const myRoom=myMemory.myRooms[i],name=creep_helper_1.CreepHelper.getName();spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.SIGNER,name,"Signer"),myMemory.empire.creeps.push({name:name,role:"Signer",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},signWords:this.message})}report_controller_1.ReportController.log("Queued a Signer for all rooms"),flag.remove()}static sign(flag,myMemory){let closestDistance=999,closestRoom=null;for(let i=0;i<myMemory.myRooms.length;i++){const myRoom=myMemory.myRooms[i],roomDistance=map_helper_1.MapHelper.getRoomDistance(flag.pos.roomName,myRoom.name);roomDistance<closestDistance&&(closestRoom=myRoom,closestDistance=roomDistance)}if(null==closestRoom)return;const name=creep_helper_1.CreepHelper.getName();spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(closestRoom,spawn_constants_1.SpawnConstants.SIGNER,name,"Signer"),myMemory.empire.creeps.push({name:name,role:"Signer",assignedRoomName:flag.pos.roomName,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},signWords:this.message}),report_controller_1.ReportController.log("Queued a Signer for room "+log_helper_1.LogHelper.roomNameAsLink(flag.pos.roomName)),flag.remove()}}exports.SignController=SignController,SignController.message="X"},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleScavenger=void 0;const creep_helper_1=__webpack_require__(3),map_helper_1=__webpack_require__(11),report_controller_1=__webpack_require__(0),movement_helper_1=__webpack_require__(7),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1);exports.RoleScavenger=class{static run(scavenger){if(creep_helper_1.CreepHelper.handleCreepPreRole(scavenger))return;const creep=Game.creeps[scavenger.name];this.checkStates(scavenger,creep),"Scavenging"===scavenger.state?this.scavenging(scavenger,creep):this.returning(scavenger,creep)}static checkStates(scavenger,creep){if("Scavenging"===scavenger.state){let returning=!1;if(0===creep.store.getFreeCapacity())returning=!0;else{if(0===creep.room.find(FIND_DROPPED_RESOURCES).length){if(0===creep.room.find(FIND_TOMBSTONES,{filter:t=>t.store.getUsedCapacity()>0}).length){if(0===creep.room.find(FIND_RUINS,{filter:t=>t.store.getUsedCapacity()>0}).length){if(0===creep.room.find(FIND_HOSTILE_STRUCTURES,{filter:struc=>room_helper_1.RoomHelper.structureHasResources(struc)}).length){0===creep.room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_BANK}).length&&(returning=!0)}}}}}if(returning){scavenger.state="Returning";const closestBank=map_helper_1.MapHelper.findClosestBank(creep.room.name,15e4);if(null==closestBank)return void report_controller_1.ReportController.email("ERROR: closestBank was null in RoleScavenger.checkStates");scavenger.assignedRoomName=closestBank.room.name}}else"Returning"===scavenger.state&&0===creep.store.getUsedCapacity()&&(null!=creep.ticksToLive&&creep.ticksToLive>=scavenger.scavengeAgainWhenTtlAbove?(scavenger.assignedRoomName=scavenger.scavengingRoomName,scavenger.state="Scavenging"):creep.suicide())}static scavenging(scavenger,creep){if(null==scavenger.scavengeTargetPos){const scavengerTargetResult=this.getTarget(creep);if(null==scavengerTargetResult){const powerBanks=creep.room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_BANK});return void(powerBanks.length>0&&!creep.pos.inRangeTo(powerBanks[0],5)&&movement_helper_1.MovementHelper.myMoveTo(creep,powerBanks[0].pos,scavenger))}scavenger.scavengeTargetPos=room_helper_1.RoomHelper.roomPosToMyPos(scavengerTargetResult.pos)}const targetPos=room_helper_1.RoomHelper.myPosToRoomPos(scavenger.scavengeTargetPos);if(creep.pos.isNearTo(targetPos)){const scavengerTargetResult=this.getTarget(creep);if(null==scavengerTargetResult)return;if(!room_helper_1.RoomHelper.posMatches(targetPos,scavengerTargetResult.pos))return void(scavenger.scavengeTargetPos=null);if(scavengerTargetResult.isResource&&null!=scavengerTargetResult.resource)creep.pickup(scavengerTargetResult.resource);else if(!scavengerTargetResult.isResource&&null!=scavengerTargetResult.structure){const resourcesInStructure=Object.keys(scavengerTargetResult.structure.store);for(let i=0;i<resourcesInStructure.length;i++)creep.withdraw(scavengerTargetResult.structure,resourcesInStructure[i])}}else movement_helper_1.MovementHelper.myMoveTo(creep,targetPos,scavenger)}static getTarget(creep){const resource=creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES);if(null!=resource)return{isResource:!0,resource:resource,pos:resource.pos,structure:null};const tombstone=creep.pos.findClosestByPath(FIND_TOMBSTONES,{filter:t=>t.store.getUsedCapacity()>0});if(null!=tombstone)return{isResource:!1,resource:null,pos:tombstone.pos,structure:tombstone};const ruin=creep.pos.findClosestByPath(FIND_RUINS,{filter:t=>t.store.getUsedCapacity()>0});if(null!=ruin)return{isResource:!1,resource:null,pos:ruin.pos,structure:ruin};const structure=creep.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:struc=>room_helper_1.RoomHelper.structureHasResources(struc)});return null!=structure?{isResource:!1,resource:null,pos:structure.pos,structure:structure}:null}static returning(scavenger,creep){const myRoom=room_helper_1.RoomHelper.getMyRoomByName(scavenger.assignedRoomName);if(null==myRoom)return void report_controller_1.ReportController.email("ERROR: myRoom was null in RoleScavenger.returning");if(null==myRoom.bank)return void report_controller_1.ReportController.email("ERROR: Scavenging deposit room's bank pos was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const bankPos=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.bank.bankPos);if(bankPos.isNearTo(creep)){const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Room's bank was null in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const resources=Object.keys(creep.store);for(let i=0;i<resources.length&&creep.transfer(bank,resources[i])!==OK;i++);}else movement_helper_1.MovementHelper.myMoveTo(creep,bankPos,scavenger)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.loop=void 0;const room_controller_1=__webpack_require__(19),memory_controller_1=__webpack_require__(16),empire_controller_1=__webpack_require__(69),profiler_wrapper_1=__webpack_require__(92),function_profiler_1=__webpack_require__(94),empire_helper_1=__webpack_require__(15),constants_1=__webpack_require__(4),spawn_queue_controller_1=__webpack_require__(8);"sim"!==Game.shard.name&&console.log("Script reloaded"),profiler_wrapper_1.ProfilerWrapper.clearProfilingData(),function_profiler_1.FunctionProfiler.clearProfilingData(),null==Memory.myMemory&&(Memory.myMemory={globalId:0,myRooms:[],reports:{},empire:{oddThousand:!1,attackQuick:null,attackPressure:null,attackHealerDrain:null,creeps:[],avoidRooms:[],powerBanks:{targetBanks:[],averageDuoTravelTicksPerRoom:50,countDuoTravelTicksPerRoom:0},observer:null,transfers:[]}}),exports.loop=function(){const myMemory=Memory.myMemory;if(memory_controller_1.MemoryController.run(),empire_controller_1.EmpireController.run(myMemory),null!=Game.flags["test-run-1"]&&1===myMemory.myRooms.length){Game.flags["test-run-1"].remove();const myRoom=myMemory.myRooms[0],legolas={name:"Legolas"+Game.time,role:"Legolas",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]}};myMemory.empire.creeps.push(legolas),spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,1,"Legolas"+Game.time,"Legolas")}for(let i=0;i<myMemory.myRooms.length;i++){const transfer=empire_helper_1.EmpireHelper.getValidResourceTransfer(myMemory.empire,myMemory.myRooms[i].name);room_controller_1.RoomController.run(myMemory.myRooms[i],transfer)}Game.time%10==0&&(profiler_wrapper_1.ProfilerWrapper.detectProfileReport(),function_profiler_1.FunctionProfiler.detectProfileReport()),Game.cpu.getUsed()>20?console.log(Game.time+": Used "+Game.cpu.getUsed()+", bucket: "+Game.cpu.bucket):Game.cpu.bucket>=constants_1.Constants.GENERATE_PIXEL_WHEN_BUCKET_OVER&&Game.cpu.generatePixel()}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage6_6=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),flag_helper_1=__webpack_require__(9),report_cooldown_constants_1=__webpack_require__(6);exports.Stage6_6=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)>=myRoom.mySources.length+2&&(myRoom.roomStage=6.8,report_controller_1.ReportController.email("STAGE+ 6.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" controller link"),!0)}static down(myRoom,room){return room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LINK)<myRoom.mySources.length+2&&(myRoom.roomStage=6.6,report_controller_1.ReportController.email("STAGE- 6.6 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" controller link"),!0)}static step(myRoom,room){const flag=flag_helper_1.FlagHelper.getFlag1(["link","controller"],myRoom.name);let placedControllerLink=!1;if(null!=flag){Game.rooms[myRoom.name].createConstructionSite(flag.pos,STRUCTURE_LINK)===OK?(myRoom.controllerLink={pos:room_helper_1.RoomHelper.roomPosToMyPos(flag.pos),id:null},flag.remove(),placedControllerLink=!0,report_controller_1.ReportController.log("Placed a controller link construction site in "+log_helper_1.LogHelper.roomNameAsLink(room.name))):report_controller_1.ReportController.email("ERROR: Placing a controller link construction site errored in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}if(null!=myRoom.controllerLink){const structures=room_helper_1.RoomHelper.myPosToRoomPos(myRoom.controllerLink.pos).lookFor(LOOK_STRUCTURES);for(let j=0;j<structures.length;j++)if(structures[j].structureType===STRUCTURE_LINK)return void(myRoom.controllerLink.id=structures[j].id)}placedControllerLink||0!==Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length||report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs controller link flag (link-controller)",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_8=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6),flag_helper_1=__webpack_require__(9);exports.Stage7_8=class{static up(myRoom,room){return this.step(myRoom,room),room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LAB)>=10&&null!=myRoom.labs&&(myRoom.roomStage=7.9,report_controller_1.ReportController.email("STAGE+ 7.9 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 10 labs"),!0)}static down(myRoom,room){return(room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LAB)<10||null==myRoom.labs)&&(myRoom.roomStage=7.8,report_controller_1.ReportController.email("STAGE- 7.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" 10 labs"),!0)}static step(myRoom,room){if(room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_LAB)<10)return void(0===Game.rooms[myRoom.name].find(FIND_CONSTRUCTION_SITES).length&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs more labs built, place manually",report_cooldown_constants_1.ReportCooldownConstants.DAY));if(null!=myRoom.labs)return;const labBufferFlag=flag_helper_1.FlagHelper.getFlag1(["lab","buffer"],myRoom.name);if(null==labBufferFlag)return void report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs a buffer lab flag (lab-buffer)",report_cooldown_constants_1.ReportCooldownConstants.DAY);const labReagent1Flag=flag_helper_1.FlagHelper.getFlag1(["lab","reagent","1"],myRoom.name);if(null==labReagent1Flag)return void report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs a lab reagent 1 flag (lab-reagent-1)",report_cooldown_constants_1.ReportCooldownConstants.DAY);const labReagent2Flag=flag_helper_1.FlagHelper.getFlag1(["lab","reagent","2"],myRoom.name);if(null==labReagent2Flag)return void report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" needs a lab reagent 2 flag (lab-reagent-2)",report_cooldown_constants_1.ReportCooldownConstants.DAY);const labs=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_LAB});let bufferId=null,reagentLab1=null,reagentLab2=null;const compoundLabs=[];for(let i=0;i<labs.length;i++){const lab=labs[i];lab.pos.isEqualTo(labBufferFlag.pos)?bufferId=lab.id:lab.pos.isEqualTo(labReagent1Flag.pos)?reagentLab1={id:lab.id,resource:null}:lab.pos.isEqualTo(labReagent2Flag.pos)?reagentLab2={id:lab.id,resource:null}:compoundLabs.push({id:lab.id})}7===compoundLabs.length&&null!=bufferId&&null!=reagentLab1&&null!=reagentLab2&&(myRoom.labs={buffingLab:bufferId,reagentLab1:reagentLab1,reagentLab2:reagentLab2,compoundLabs:compoundLabs,labOrders:[]},labBufferFlag.remove(),labReagent1Flag.remove(),labReagent2Flag.remove())}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Stage7_7=void 0;const room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),report_cooldown_constants_1=__webpack_require__(6);exports.Stage7_7=class{static up(myRoom,room){return this.step(room),1===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_NUKER)&&(myRoom.roomStage=7.8,report_controller_1.ReportController.email("STAGE+ 7.8 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" nuker"),!0)}static down(myRoom,room){return 0===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_NUKER)&&(myRoom.roomStage=7.7,report_controller_1.ReportController.email("STAGE- 7.7 "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" nuker"),!0)}static step(room){0===room.find(FIND_CONSTRUCTION_SITES).length&&0===room_helper_1.RoomHelper.amountOfStructure(room,STRUCTURE_NUKER)&&report_controller_1.ReportController.email("ATTENTION: Room "+log_helper_1.LogHelper.roomNameAsLink(room.name)+" needs a nuker, place manually",report_cooldown_constants_1.ReportCooldownConstants.DAY)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnDigger=void 0;const spawn_queue_controller_1=__webpack_require__(8),spawn_constants_1=__webpack_require__(10),creep_helper_1=__webpack_require__(3),constants_1=__webpack_require__(4);exports.SpawnDigger=class{static spawnDigger(myRoom){if(Game.time%100!=0)return;if(myRoom.roomStage<constants_1.Constants.MINERAL_START_STAGE||!myRoom.digging.active||null!=myRoom.digging.diggerName||null==myRoom.digging.cache)return;{const minerals=Game.rooms[myRoom.name].find(FIND_MINERALS);if(1===minerals.length&&0===minerals[0].mineralAmount)return}const digger=this.spawnDiggerInternal(myRoom,myRoom.digging.cache.pos);myRoom.myCreeps.push(digger),myRoom.digging.diggerName=digger.name}static getBody(myRoom){return creep_helper_1.CreepHelper.generateBody([MOVE,WORK,WORK,WORK,WORK,WORK],[MOVE,WORK,WORK,WORK,WORK,WORK],Game.rooms[myRoom.name],!0,42)}static spawnDiggerInternal(myRoom,cachePos){const name=creep_helper_1.CreepHelper.getName();return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,spawn_constants_1.SpawnConstants.DIGGER,name,"Digger"),{name:name,role:"Digger",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},cachePosToDigOn:cachePos,mineralId:myRoom.digging.mineralId,digInTick:0}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpawnUpgrader=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),constants_1=__webpack_require__(4),creep_helper_1=__webpack_require__(3),spawn_constants_1=__webpack_require__(10),spawn_queue_controller_1=__webpack_require__(8);exports.SpawnUpgrader=class{static spawnUpgraderLogic(myRoom){if(myRoom.roomStage<constants_1.Constants.CONTROLLER_LINKED_STAGE||null==myRoom.bank)return;for(let i=0;i<myRoom.myCreeps.length;i++){const myCreep=myRoom.myCreeps[i];if("Upgrader"===myCreep.role){const ticksToTravel=myCreep.ticksToTravel,creep=Game.creeps[myCreep.name];if(null==ticksToTravel||null==creep.ticksToLive||creep.ticksToLive>=ticksToTravel+constants_1.Constants.UPGRADER_TICKS_TO_SPAWN)return}}const bank=myRoom.bank.object;if(null==bank)return void report_controller_1.ReportController.email("ERROR: Bank is null when checking if it's full in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));if(bank.store.energy<constants_1.Constants.AMOUNT_OF_BANK_ENERGY_REQUIRED_TO_SPAWN_UPGRADER&&Game.rooms[myRoom.name].controller.ticksToDowngrade>=constants_1.Constants.STAGE_8_SPAWN_UPGRADERS_WHEN_CONTROLLER_BENEATH)return;const upgrader=this.spawnUpgrader(myRoom);myRoom.myCreeps.push(upgrader)}static getBody(myRoom){return[CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK]}static spawnUpgrader(myRoom){const name=creep_helper_1.CreepHelper.getName(),priority=spawn_constants_1.SpawnConstants.UPGRADER;return spawn_queue_controller_1.SpawnQueueController.queueCreepSpawn(myRoom,priority,name,"Upgrader"),{name:name,role:"Upgrader",assignedRoomName:myRoom.name,spawningStatus:"queued",roomMoveTarget:{pos:null,path:[]},ticksToTravel:null}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RolePowerBankHealCreep=void 0;const creep_helper_1=__webpack_require__(3),movement_helper_1=__webpack_require__(7),room_helper_1=__webpack_require__(2),report_controller_1=__webpack_require__(0);exports.RolePowerBankHealCreep=class{static run(powerBankHeal,myPowerBank,powerBank,powerBankAttack){if(creep_helper_1.CreepHelper.handleCreepPreRole(powerBankHeal))return;const creep=Game.creeps[powerBankHeal.name];if(null==powerBank||null==powerBankAttack)return creep.say("dthb4dshnr"),void creep.suicide();if(powerBankHeal.reachedPowerBank){const attackCreep=Game.creeps[powerBankAttack.name];creep.heal(attackCreep)}else if(powerBankAttack.reachedPowerBank){const attackCreep=Game.creeps[powerBankAttack.name],idealPos=room_helper_1.RoomHelper.getPosOnOtherSide(powerBank.pos,attackCreep.pos);creep.room.getTerrain().get(idealPos.x,idealPos.y)===TERRAIN_MASK_WALL?creep.pos.isNearTo(attackCreep)?(report_controller_1.ReportController.log("Power Bank Heal Creep reached power bank, non ideal spot"),powerBankHeal.reachedPowerBank=!0):movement_helper_1.MovementHelper.myMoveTo(creep,attackCreep.pos,powerBankHeal):room_helper_1.RoomHelper.posMatches3(creep.pos,idealPos)?(report_controller_1.ReportController.log("Power Bank Heal Creep reached power bank, ideal spot"),powerBankHeal.reachedPowerBank=!0):movement_helper_1.MovementHelper.myMoveTo(creep,idealPos,powerBankHeal)}else creep.pos.inRangeTo(powerBank,5)||movement_helper_1.MovementHelper.myMoveTo(creep,powerBank.pos,powerBankHeal)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleDigger=void 0;const creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7);exports.RoleDigger=class{static run(digger,myRoom){if(creep_helper_1.CreepHelper.handleCreepPreRole(digger))return;if(Game.time<digger.digInTick)return;const creep=Game.creeps[digger.name],cachePos=room_helper_1.RoomHelper.myPosToRoomPos(digger.cachePosToDigOn);if(cachePos.isEqualTo(creep.pos)){const mineral=Game.getObjectById(digger.mineralId);if(null==mineral)return void report_controller_1.ReportController.email("ERROR: Digger has been given a mineral which is null. Creep ID: "+digger.name+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));if(mineral.mineralAmount>0){if(null==myRoom.digging.cache||null==myRoom.digging.cache.id)return void report_controller_1.ReportController.email("ERROR: Digger has mineral cache was null. Creep ID: "+digger.name+" in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const cache=Game.getObjectById(myRoom.digging.cache.id);null!=cache?cache.store.energy<1965&&(creep.harvest(mineral),digger.digInTick=Game.time+6):report_controller_1.ReportController.email("ERROR: Mineral cache returned null with get by ID in "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name))}}else movement_helper_1.MovementHelper.myMoveTo(creep,cachePos,digger)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleUpgrader=void 0;const report_controller_1=__webpack_require__(0),log_helper_1=__webpack_require__(1),creep_helper_1=__webpack_require__(3),movement_helper_1=__webpack_require__(7);exports.RoleUpgrader=class{static run(upgrader,myRoom){if(creep_helper_1.CreepHelper.handleCreepPreRole(upgrader))return;const controller=Game.rooms[myRoom.name].controller,creep=Game.creeps[upgrader.name];if(creep.store.energy<30){if(null==myRoom.controllerLink||null==myRoom.controllerLink.id)return void report_controller_1.ReportController.email("ERROR: myRoom.controllerLink null in upgrader role in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));const link=Game.getObjectById(myRoom.controllerLink.id);if(null==link)return void report_controller_1.ReportController.email("ERROR: Get link was null in upgrader role in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name));creep.withdraw(link,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE?(movement_helper_1.MovementHelper.myMoveTo(creep,link.pos,upgrader),creep.upgradeController(controller)):(creep.upgradeController(controller)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,controller.pos,upgrader),null==upgrader.ticksToTravel&&(upgrader.ticksToTravel=1500-creep.ticksToLive))}else creep.upgradeController(controller)===ERR_NOT_IN_RANGE&&movement_helper_1.MovementHelper.myMoveTo(creep,controller.pos,upgrader)}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoomPowerSpawnController=void 0;const report_controller_1=__webpack_require__(0),constants_1=__webpack_require__(4);exports.RoomPowerSpawnController=class{static run(myRoom,room){this.determinePowerSpawnStatus(myRoom,room)}static determinePowerSpawnStatus(myRoom,room){if(null==myRoom.powerSpawn)return;const powerSpawns=room.find(FIND_STRUCTURES,{filter:structure=>structure.structureType===STRUCTURE_POWER_SPAWN});if(1!==powerSpawns.length)return report_controller_1.ReportController.email("ERROR: powerSpawns length isn't 1, setting it to null"),void(myRoom.powerSpawn=null);const powerSpawn=powerSpawns[0];powerSpawn.store.energy<=constants_1.Constants.POWER_SPAWN_RESTOCK_WHEN_ENERGY_BELOW?myRoom.powerSpawn.resources="Restock":myRoom.powerSpawn.resources="Good",powerSpawn.store.energy>=1&&powerSpawn.store.power>=1&&powerSpawn.processPower()}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MineralController=void 0;const room_helper_1=__webpack_require__(2),constants_1=__webpack_require__(4),log_helper_1=__webpack_require__(1),report_controller_1=__webpack_require__(0),resource_constants_1=__webpack_require__(90);class MineralController{static run(myMemory){if(Game.time%100!=0)return;const roomsToUse=room_helper_1.RoomHelper.getMyRoomsAtOrAboveStage(constants_1.Constants.MINERAL_START_STAGE),resourceMap=this.generateResourceMap(roomsToUse,myMemory.empire.transfers),mineralLimits=resource_constants_1.ResourceConstants.getMineralLimits(),forceDigResource=this.transferMineralsToLowRooms(roomsToUse,resourceMap,myMemory.empire.transfers,mineralLimits);this.startOrStopDigging(roomsToUse,resourceMap.totalResourceMap,mineralLimits,forceDigResource),this.donateEnergyToDevelopingRooms(roomsToUse,resourceMap,myMemory.empire.transfers),this.queueLabOrders(roomsToUse,resourceMap)}static queueLabOrders(roomsToUse,resourceMap){const baseCompoundLimits=resource_constants_1.ResourceConstants.getBaseCompoundLimits(),gCompoundLimits=resource_constants_1.ResourceConstants.getGCompoundLimits();let newLabOrders=0,labOrdersThatFailedToQueue=0,totalLabOrders=0;for(let i=0;i<roomsToUse.length;i++){const myRoom=roomsToUse[i];if(myRoom.roomStage<8)continue;const roomResourceMap=resourceMap.myRoomMaps[myRoom.name],statsFromBaseQueuing=this.tryQueueLabOrderForRoom(myRoom,roomResourceMap,baseCompoundLimits,0),statsFromGQueuing=this.tryQueueLabOrderForRoom(myRoom,roomResourceMap,gCompoundLimits,.5);newLabOrders+=statsFromBaseQueuing.newLabOrders+statsFromGQueuing.newLabOrders,labOrdersThatFailedToQueue+=statsFromBaseQueuing.labOrdersThatFailedToQueue+statsFromGQueuing.labOrdersThatFailedToQueue,totalLabOrders+=myRoom.labs.labOrders.length}0===totalLabOrders&&0===labOrdersThatFailedToQueue&&0===newLabOrders?report_controller_1.ReportController.log("Rooms are content with current compounds"):(report_controller_1.ReportController.log("New lab orders: "+newLabOrders),report_controller_1.ReportController.log("Lab orders that failed to queue: "+labOrdersThatFailedToQueue),report_controller_1.ReportController.log("Total lab orders: "+totalLabOrders))}static tryQueueLabOrderForRoom(myRoom,roomResourceMap,tieredResourceLimits,priority){const statsResults={newLabOrders:0,labOrdersThatFailedToQueue:0},resources=Object.keys(tieredResourceLimits);for(let i=0;i<resources.length;i++){const resource=resources[i],resourceLimits=tieredResourceLimits[resource],amountOfResource=this.getAmountOfResource(roomResourceMap,resource);if(amountOfResource<resourceLimits.lower){let alreadyExistingOrderForThisResource=!1;for(let j=0;j<myRoom.labs.labOrders.length;j++){if(myRoom.labs.labOrders[j].compound===resource){alreadyExistingOrderForThisResource=!0;break}}if(alreadyExistingOrderForThisResource)continue;let amountNeeded=Math.ceil((resourceLimits.upper-amountOfResource)/constants_1.Constants.LAB_REACTION_AMOUNT_TO_CEIL_TO)*constants_1.Constants.LAB_REACTION_AMOUNT_TO_CEIL_TO,amounts=[];if(amountNeeded>3e3){const lots=Math.floor(amountNeeded/3e3);for(let j=0;j<lots;j++)amounts.push(3e3);const leftOver=amountNeeded-3e3*lots;amounts.push(leftOver)}else amounts.push(amountNeeded);if(null==myRoom.bank||null==myRoom.bank.object){report_controller_1.ReportController.log("LOG: Can't create resource "+resource+" in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" bank being null"),statsResults.labOrdersThatFailedToQueue+=1;continue}const amountOfReagent1=this.getAmountOfResource(roomResourceMap,resourceLimits.reagent1);if(amountOfReagent1<amountNeeded||myRoom.bank.object.store.getUsedCapacity(resourceLimits.reagent1)<amountNeeded){if(!(amounts.length>1&&amountOfReagent1>=3e3&&myRoom.bank.object.store.getUsedCapacity(resourceLimits.reagent1)>=3e3)){report_controller_1.ReportController.log("LOG: Can't create resource "+resource+" in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" due to lack of r1 "+resourceLimits.reagent1+" ("+amountOfReagent1+")"),statsResults.labOrdersThatFailedToQueue+=1;continue}amounts=[3e3],amountNeeded=3e3}const amountOfReagent2=this.getAmountOfResource(roomResourceMap,resourceLimits.reagent2);if(amountOfReagent2<amountNeeded||myRoom.bank.object.store.getUsedCapacity(resourceLimits.reagent2)<amountNeeded){if(!(amounts.length>1&&amountOfReagent2>=3e3&&myRoom.bank.object.store.getUsedCapacity(resourceLimits.reagent2)>=3e3)){report_controller_1.ReportController.log("LOG: Can't create resource "+resource+" in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" due to lack of r2 "+resourceLimits.reagent2+" ("+amountOfReagent2+")"),statsResults.labOrdersThatFailedToQueue+=1;continue}amounts=[3e3],amountNeeded=3e3}for(let j=0;j<amounts.length;j++)this.queueLabOrder(myRoom,resource,amounts[j],resourceLimits,priority);null!=roomResourceMap[resourceLimits.reagent1]&&(roomResourceMap[resourceLimits.reagent1]-=amountNeeded),null!=roomResourceMap[resourceLimits.reagent2]&&(roomResourceMap[resourceLimits.reagent2]-=amountNeeded),report_controller_1.ReportController.log("LOG: Queued a new reaction for room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" to create "+resource),statsResults.newLabOrders+=amounts.length}}return statsResults}static queueLabOrder(myRoom,resource,amountNeeded,resourceLimits,priority){const newLabOrder={amount:amountNeeded,amountLeftToLoad:amountNeeded,compound:resource,reagent1:resourceLimits.reagent1,reagent2:resourceLimits.reagent2,state:"Queued",priority:priority,cooldown:resourceLimits.cooldown,cooldownTill:0};if(0===myRoom.labs.labOrders.length)myRoom.labs.labOrders.push(newLabOrder);else{let inserted=!1;for(let j=0;j<myRoom.labs.labOrders.length;j++)if(newLabOrder.priority<myRoom.labs.labOrders[j].priority){myRoom.labs.labOrders.splice(j,0,newLabOrder),inserted=!0;break}inserted||(myRoom.labs.labOrders=myRoom.labs.labOrders.concat(newLabOrder))}}static donateEnergyToDevelopingRooms(roomsToUse,resourceMap,transfers){const alreadyDonatedToThisTick=[];for(let i=0;i<roomsToUse.length;i++){const donorRoom=roomsToUse[i];if(8!==donorRoom.roomStage)continue;const donorRoomResourceMap=resourceMap.myRoomMaps[donorRoom.name];if(null!=donorRoomResourceMap.energy&&donorRoomResourceMap.energy>=constants_1.Constants.STAGE_8_DONATE_AT){let lowestEnergyAmount=constants_1.Constants.DONT_DONATE_TO_ROOMS_WITH_ABOVE_ENERGY,lowestEnergyIndex=-1;for(let j=0;j<roomsToUse.length;j++){const doneeRoom=roomsToUse[j];if(doneeRoom.roomStage<6||doneeRoom.roomStage>7&&doneeRoom.mySources.length>=2)continue;if(alreadyDonatedToThisTick.includes(doneeRoom.name))continue;const doneeRoomResourceMap=resourceMap.myRoomMaps[doneeRoom.name];if(null!=doneeRoomResourceMap.energy&&doneeRoomResourceMap.energy<lowestEnergyAmount&&doneeRoomResourceMap.energy<constants_1.Constants.DONT_DONATE_TO_ROOMS_WITH_ABOVE_ENERGY){if(doneeRoom.mySources.length<2&&8===doneeRoom.roomStage&&doneeRoomResourceMap.energy>=constants_1.Constants.STAGE_8_ONE_SOURCE_ENERGY_DONATE_TARGET)continue;lowestEnergyAmount=doneeRoomResourceMap.energy,lowestEnergyIndex=j}}if(-1===lowestEnergyIndex)return void report_controller_1.ReportController.log("No room wants energy");this.createTransfer(donorRoom.name,roomsToUse[lowestEnergyIndex].name,"energy",constants_1.Constants.STAGE_8_DONATE_AMOUNT,donorRoomResourceMap,transfers),alreadyDonatedToThisTick.push(roomsToUse[lowestEnergyIndex].name)}}}static transferMineralsToLowRooms(roomsToUse,resourceMap,transfers,mineralLimits){const forceDigResources=[];for(let i=0;i<roomsToUse.length;i++){const myRoom=roomsToUse[i],roomResourceMap=resourceMap.myRoomMaps[myRoom.name],resources=Object.keys(mineralLimits);for(let j=0;j<resources.length;j++){const resource=resources[j],resourceLimits=mineralLimits[resource],amountOfMineral=this.getAmountOfResource(roomResourceMap,resource);if(amountOfMineral<resourceLimits.lower)if(resource!==myRoom.digging.mineral||myRoom.digging.active){const amountNeeded=Math.ceil((resourceLimits.upper-amountOfMineral)/constants_1.Constants.BANK_LINKER_CAPACITY)*constants_1.Constants.BANK_LINKER_CAPACITY;this.requestTransfer(myRoom,resource,amountNeeded,roomsToUse,resourceMap,transfers,resourceLimits.lower)||forceDigResources.includes(resource)||forceDigResources.push(resource)}else myRoom.digging.active=!0,report_controller_1.ReportController.log("Room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" is low on its own mineral ("+myRoom.digging.mineral+"), setting digging to true")}}return forceDigResources}static requestTransfer(receivingRoom,resource,amountNeeded,roomsToUse,resourceMap,transfers,resourceLimitLower){let highestFoundAmount=-1,highestFoundIndex=-1;for(let i=0;i<roomsToUse.length;i++){const potentialRoomToTransferFrom=roomsToUse[i];if(null==potentialRoomToTransferFrom.digging||potentialRoomToTransferFrom.digging.mineral!==resource)continue;const potentialRoomToTransferFromResourceMap=resourceMap.myRoomMaps[potentialRoomToTransferFrom.name];potentialRoomToTransferFrom.name===receivingRoom.name||null==potentialRoomToTransferFromResourceMap[resource]||potentialRoomToTransferFromResourceMap[resource]<=highestFoundAmount||potentialRoomToTransferFromResourceMap[resource]<=amountNeeded||potentialRoomToTransferFromResourceMap[resource]<=amountNeeded+resourceLimitLower||(highestFoundAmount=potentialRoomToTransferFromResourceMap[resource],highestFoundIndex=i)}return-1!==highestFoundIndex&&(this.createTransfer(roomsToUse[highestFoundIndex].name,receivingRoom.name,resource,amountNeeded,resourceMap.myRoomMaps[roomsToUse[highestFoundIndex].name],transfers),!0)}static createTransfer(sendingRoomName,receivingRoomName,resource,amount,sendingRoomResourceMap,transfers){const transfer={amount:amount,amountLeft:amount,resource:resource,roomFrom:sendingRoomName,roomTo:receivingRoomName,state:"Loading",actionStarted:!1};transfers.push(transfer),sendingRoomResourceMap[resource]-=amount,report_controller_1.ReportController.log("Loading "+transfer.amount+" "+transfer.resource+" from "+log_helper_1.LogHelper.roomNameAsLink(transfer.roomFrom)+" to "+log_helper_1.LogHelper.roomNameAsLink(transfer.roomTo))}static startOrStopDigging(roomsToUse,totalResourceMap,mineralLimits,forceDigResource){const resources=Object.keys(mineralLimits);for(let i=0;i<resources.length;i++){const mineral=resources[i];if(forceDigResource.includes(mineral)){this.setDiggingActive(roomsToUse,mineral,!0);continue}const mineralLimitUpper=mineralLimits[mineral].upper*roomsToUse.length;this.getAmountOfResource(totalResourceMap,mineral)>mineralLimitUpper?this.setDiggingActive(roomsToUse,mineral,!1):this.setDiggingActive(roomsToUse,mineral,!0)}}static setDiggingActive(roomsToUse,mineral,active){for(let i=0;i<roomsToUse.length;i++){const myRoom=roomsToUse[i];myRoom.digging.mineral===mineral&&myRoom.digging.active!==active&&(myRoom.digging.active=active,report_controller_1.ReportController.log("Set digging active to "+active+" in room "+log_helper_1.LogHelper.roomNameAsLink(myRoom.name)+" for mineral "+mineral))}}static generateResourceMap(roomsToUse,transfers){const result={myRoomMaps:{},totalResourceMap:{}};for(let i=0;i<roomsToUse.length;i++){const myRoom=roomsToUse[i],roomResourceMap={},room=Game.rooms[myRoom.name];room.find(FIND_MY_CREEPS,{filter(creep){if(creep.store.getUsedCapacity()>0){const resources=Object.keys(creep.store);for(let j=0;j<resources.length;j++){const resource=resources[j];MineralController.addToResourceMap(roomResourceMap,resource,creep.store[resource]),MineralController.addToResourceMap(result.totalResourceMap,resource,creep.store[resource])}}return!1}}),room.find(FIND_MY_STRUCTURES,{filter(structure){if(structure.structureType!==STRUCTURE_EXTENSION&&structure.structureType!==STRUCTURE_SPAWN&&structure.structureType!==STRUCTURE_NUKER&&structure.structureType!==STRUCTURE_FACTORY&&structure.structureType!==STRUCTURE_TOWER&&structure.structureType!==STRUCTURE_TERMINAL&&room_helper_1.RoomHelper.structureHasResources(structure)){const resources=Object.keys(structure.store);for(let j=0;j<resources.length;j++){const resource=resources[j];MineralController.addToResourceMap(roomResourceMap,resource,structure.store[resource]),MineralController.addToResourceMap(result.totalResourceMap,resource,structure.store[resource])}}return!1}});for(let j=0;j<transfers.length;j++){const transfer=transfers[j];transfer.roomFrom===myRoom.name&&"Loading"===transfer.state?MineralController.addToResourceMap(roomResourceMap,transfer.resource,-transfer.amountLeft):transfer.roomTo===myRoom.name&&("Loading"===transfer.state?MineralController.addToResourceMap(roomResourceMap,transfer.resource,transfer.amount):"Unloading"!==transfer.state&&"Sending"!==transfer.state||MineralController.addToResourceMap(roomResourceMap,transfer.resource,transfer.amountLeft))}result.myRoomMaps[myRoom.name]=roomResourceMap}return result}static addToResourceMap(resourceMap,resource,amount){null==resourceMap[resource]?resourceMap[resource]=amount:resourceMap[resource]+=amount}static getAmountOfResource(resourceMap,resource){return null==resourceMap[resource]?0:resourceMap[resource]}}exports.MineralController=MineralController},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResourceConstants=void 0;exports.ResourceConstants=class{static getMineralLimits(){return{Z:{lower:5e3,upper:1e4},K:{lower:5e3,upper:1e4},U:{lower:5e3,upper:1e4},L:{lower:5e3,upper:1e4},H:{lower:5e3,upper:1e4},O:{lower:5e3,upper:1e4},X:{lower:5e3,upper:1e4}}}static getBaseCompoundLimits(){return{ZK:{lower:5e3,upper:1e4,reagent1:"Z",reagent2:"K",cooldown:5},UL:{lower:5e3,upper:1e4,reagent1:"U",reagent2:"L",cooldown:5}}}static getGCompoundLimits(){return{G:{lower:5e3,upper:1e4,reagent1:"ZK",reagent2:"UL",cooldown:5}}}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RoleLegolas=void 0;const creep_helper_1=__webpack_require__(3),flag_helper_1=__webpack_require__(9),room_helper_1=__webpack_require__(2),movement_helper_1=__webpack_require__(7);exports.RoleLegolas=class{static run(legolas){if(creep_helper_1.CreepHelper.handleCreepPreRole(legolas))return;const creep=Game.creeps[legolas.name],standOnFlag=flag_helper_1.FlagHelper.getFlag1(["test","stand","on"],creep.room.name);null==standOnFlag||room_helper_1.RoomHelper.posMatches3(creep.pos,standOnFlag.pos)||movement_helper_1.MovementHelper.myMoveTo(creep,standOnFlag.pos,legolas);0!==creep.room.find(FIND_HOSTILE_CREEPS).length&&null!=Game.flags["test-distance-to"]&&console.log(creep.pos.getRangeTo(Game.flags["test-distance-to"]))}}},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ProfilerWrapper=void 0;const profiler_1=__webpack_require__(93),laborer_1=__webpack_require__(55),attack_creep_1=__webpack_require__(18),claimer_1=__webpack_require__(70),empire_controller_1=__webpack_require__(69),attack_controller_1=__webpack_require__(71),attack_helper_functions_1=__webpack_require__(12),attack_pressure_controller_1=__webpack_require__(73),attack_quick_controller_1=__webpack_require__(72),spawn_claimer_controller_1=__webpack_require__(17),report_controller_1=__webpack_require__(0),bank_linker_1=__webpack_require__(63),hauler_1=__webpack_require__(22),miner_1=__webpack_require__(21),room_spawn_controller_1=__webpack_require__(56),spawn_bank_linker_1=__webpack_require__(61),spawn_hauler_1=__webpack_require__(58),spawn_laborer_1=__webpack_require__(57),spawn_miner_1=__webpack_require__(60),stage0_1=__webpack_require__(25),stage0_5_1=__webpack_require__(26),stage1_1=__webpack_require__(27),stage1_5_1=__webpack_require__(28),stage2_8_1=__webpack_require__(29),stage2_1=__webpack_require__(30),stage2_5_1=__webpack_require__(31),stage3_1=__webpack_require__(32),stage3_3_1=__webpack_require__(33),stage3_6_1=__webpack_require__(34),stage4_1=__webpack_require__(35),stage4_2_1=__webpack_require__(36),stage4_4_1=__webpack_require__(37),stage4_6_1=__webpack_require__(38),stage4_8_1=__webpack_require__(39),stage5_1=__webpack_require__(40),stage5_2_1=__webpack_require__(41),stage5_4_1=__webpack_require__(42),stage5_6_1=__webpack_require__(43),stage5_8_1=__webpack_require__(44),stage_default_1=__webpack_require__(24),stage_functions_1=__webpack_require__(5),tower_1=__webpack_require__(20),room_controller_1=__webpack_require__(19),room_stage_controller_1=__webpack_require__(23),stage6_8_1=__webpack_require__(48),stage7_6_1=__webpack_require__(52),stage7_9_1=__webpack_require__(53),stage7_2_1=__webpack_require__(50),stage6_1=__webpack_require__(45),stage6_4_1=__webpack_require__(47),stage7_4_1=__webpack_require__(51),stage6_2_1=__webpack_require__(46),stage7_1=__webpack_require__(49),build_observer_controller_1=__webpack_require__(75),power_bank_controller_1=__webpack_require__(14),observer_controller_1=__webpack_require__(76),memory_controller_1=__webpack_require__(16),spawn_queue_controller_1=__webpack_require__(8),creep_helper_1=__webpack_require__(3),room_helper_1=__webpack_require__(2),log_helper_1=__webpack_require__(1),movement_helper_1=__webpack_require__(7),map_helper_1=__webpack_require__(11),flag_helper_1=__webpack_require__(9),empire_helper_1=__webpack_require__(15),scavenge_controller_1=__webpack_require__(13),scavenger_1=__webpack_require__(78),attack_healer_drain_controller_1=__webpack_require__(74),sign_controller_1=__webpack_require__(77),stocker_1=__webpack_require__(65),spawn_stocker_1=__webpack_require__(59),room_defense_controller_1=__webpack_require__(67),link_1=__webpack_require__(64),power_bank_attack_creep_1=__webpack_require__(62),stage2_2_1=__webpack_require__(54);exports.ProfilerWrapper=class{static setup(){profiler_1.Profiler.setup(attack_controller_1.AttackController,"AttackController"),profiler_1.Profiler.setup(attack_healer_drain_controller_1.AttackHealerDrainController,"AttackHealerDrainController"),profiler_1.Profiler.setup(attack_helper_functions_1.AttackHelperFunctions,"AttackHelperFunctions"),profiler_1.Profiler.setup(attack_pressure_controller_1.AttackPressureController,"AttackPressureController"),profiler_1.Profiler.setup(attack_quick_controller_1.AttackQuickController,"AttackQuickController"),profiler_1.Profiler.setup(build_observer_controller_1.BuildObserverController,"BuildObserverController"),profiler_1.Profiler.setup(observer_controller_1.ObserverController,"ObserverController"),profiler_1.Profiler.setup(attack_creep_1.RoleAttackCreep,"RoleAttackCreep"),profiler_1.Profiler.setup(claimer_1.RoleClaimer,"RoleClaimer"),profiler_1.Profiler.setup(power_bank_attack_creep_1.RolePowerBankAttackCreep,"PowerBankAttackCreep"),profiler_1.Profiler.setup(scavenger_1.RoleScavenger,"RoleScavenger"),profiler_1.Profiler.setup(sign_controller_1.SignController,"SignController"),profiler_1.Profiler.setup(empire_controller_1.EmpireController,"EmpireController"),profiler_1.Profiler.setup(power_bank_controller_1.PowerBankController,"PowerScavController"),profiler_1.Profiler.setup(scavenge_controller_1.ScavengeController,"ScavengeController"),profiler_1.Profiler.setup(spawn_claimer_controller_1.SpawnClaimerController,"SpawnClaimerController"),profiler_1.Profiler.setup(creep_helper_1.CreepHelper,"CreepHelper"),profiler_1.Profiler.setup(empire_helper_1.EmpireHelper,"EmpireHelper"),profiler_1.Profiler.setup(flag_helper_1.FlagHelper,"FlagHelper"),profiler_1.Profiler.setup(log_helper_1.LogHelper,"LogHelper"),profiler_1.Profiler.setup(map_helper_1.MapHelper,"MapHelper"),profiler_1.Profiler.setup(movement_helper_1.MovementHelper,"MovementHelper"),profiler_1.Profiler.setup(room_helper_1.RoomHelper,"RoomHelper"),profiler_1.Profiler.setup(spawn_queue_controller_1.SpawnQueueController,"SpawnQueueController"),profiler_1.Profiler.setup(memory_controller_1.MemoryController,"MemoryController"),profiler_1.Profiler.setup(report_controller_1.ReportController,"ReportController"),profiler_1.Profiler.setup(bank_linker_1.RoleBankLinker,"RoleBankLinker"),profiler_1.Profiler.setup(hauler_1.RoleHauler,"RoleHauler"),profiler_1.Profiler.setup(miner_1.RoleMiner,"RoleMiner"),profiler_1.Profiler.setup(laborer_1.RoleLaborer,"RoleLaborer"),profiler_1.Profiler.setup(stocker_1.RoleStocker,"RoleStocker"),profiler_1.Profiler.setup(room_spawn_controller_1.RoomSpawnController,"RoomSpawnController"),profiler_1.Profiler.setup(spawn_bank_linker_1.SpawnBankLinker,"SpawnBankLinker"),profiler_1.Profiler.setup(spawn_hauler_1.SpawnHauler,"SpawnHauler"),profiler_1.Profiler.setup(spawn_laborer_1.SpawnLaborer,"SpawnLaborer"),profiler_1.Profiler.setup(spawn_miner_1.SpawnMiner,"SpawnMiner"),profiler_1.Profiler.setup(spawn_stocker_1.SpawnStocker,"SpawnStocker"),profiler_1.Profiler.setup(stage0_1.Stage0,"Stage0"),profiler_1.Profiler.setup(stage0_5_1.Stage0_5,"Stage0_5"),profiler_1.Profiler.setup(stage1_1.Stage1,"Stage1"),profiler_1.Profiler.setup(stage1_5_1.Stage1_5,"Stage1_5"),profiler_1.Profiler.setup(stage2_1.Stage2,"Stage2"),profiler_1.Profiler.setup(stage2_2_1.Stage2_2,"Stage2_2"),profiler_1.Profiler.setup(stage2_5_1.Stage2_5,"Stage2_5"),profiler_1.Profiler.setup(stage2_8_1.Stage2_8,"Stage2_8"),profiler_1.Profiler.setup(stage3_1.Stage3,"Stage3"),profiler_1.Profiler.setup(stage3_3_1.Stage3_3,"Stage3_3"),profiler_1.Profiler.setup(stage3_6_1.Stage3_6,"Stage3_6"),profiler_1.Profiler.setup(stage4_1.Stage4,"Stage4"),profiler_1.Profiler.setup(stage4_2_1.Stage4_2,"Stage4_2"),profiler_1.Profiler.setup(stage4_4_1.Stage4_4,"Stage4_4"),profiler_1.Profiler.setup(stage4_6_1.Stage4_6,"Stage4_6"),profiler_1.Profiler.setup(stage4_8_1.Stage4_8,"Stage4_8"),profiler_1.Profiler.setup(stage5_1.Stage5,"Stage5"),profiler_1.Profiler.setup(stage5_2_1.Stage5_2,"Stage5_2"),profiler_1.Profiler.setup(stage5_4_1.Stage5_4,"Stage5_4"),profiler_1.Profiler.setup(stage5_6_1.Stage5_6,"Stage5_6"),profiler_1.Profiler.setup(stage5_8_1.Stage5_8,"Stage5_8"),profiler_1.Profiler.setup(stage6_1.Stage6,"Stage6"),profiler_1.Profiler.setup(stage6_4_1.Stage6_4,"Stage6_5"),profiler_1.Profiler.setup(stage6_2_1.Stage6_2,"Stage6_25"),profiler_1.Profiler.setup(stage6_8_1.Stage6_8,"Stage6_75"),profiler_1.Profiler.setup(stage7_1.Stage7,"Stage7"),profiler_1.Profiler.setup(stage7_2_1.Stage7_2,"Stage7_2"),profiler_1.Profiler.setup(stage7_4_1.Stage7_4,"Stage7_4"),profiler_1.Profiler.setup(stage7_6_1.Stage7_6,"Stage7_6"),profiler_1.Profiler.setup(stage7_9_1.Stage7_9,"Stage7_8"),profiler_1.Profiler.setup(stage_default_1.StageDefault,"StageDefault"),profiler_1.Profiler.setup(stage_functions_1.StageFunctions,"StageFunctions"),profiler_1.Profiler.setup(link_1.RoomLinkController,"RoomLinkController"),profiler_1.Profiler.setup(tower_1.RoomTowerController,"RoomTowerController"),profiler_1.Profiler.setup(room_controller_1.RoomController,"RoomController"),profiler_1.Profiler.setup(room_defense_controller_1.RoomDefenseController,"RoomDefenseController"),profiler_1.Profiler.setup(room_stage_controller_1.RoomStageController,"RoomStageController")}static clearProfilingData(){Memory.profiler={startTick:Game.time}}static detectProfileReport(){if(null==Game.flags.profile)return;const profile=Memory.profiler;console.log("Profiling report:");const totalTicks=Game.time-profile.startTick+1;console.log("TotalTicks: "+totalTicks);const table=[];table[0]=["Name","AvgMsPerTick","AvgCallsPerTick","AvgMsPerCall","Calls"];const classes=Object.keys(profile);classes.splice(classes.indexOf("startTick"),1);const processedClasses=[];for(let i=0;i<classes.length;i++){const c=classes[i],processedClass=this.getProcessedClassData(profile[c],c,totalTicks);processedClasses.push(processedClass)}processedClasses.sort((a,b)=>b.avgMsUsagePerTick-a.avgMsUsagePerTick);let index=1;for(let i=0;i<SHOW_TOP_X_CLASSES;i++){const processedClass=processedClasses[i];table[index]=[processedClass.className,Number(processedClass.avgMsUsagePerTick.toFixed(FIXED_NUMBER)).toString(),"","",""],index++;for(let j=0;j<processedClass.functions.length;j++){const processedFunction=processedClass.functions[j];table[index]=["+ "+processedFunction.functionName,Number(processedFunction.avgMsUsagePerTick.toFixed(FIXED_NUMBER)).toString(),Number(processedFunction.callsPerTickAvg.toFixed(FIXED_NUMBER)).toString(),Number(processedFunction.avgTime.toFixed(FIXED_NUMBER)).toString(),processedFunction.callCount.toString()],index++}}console.log("Top "+SHOW_TOP_X_CLASSES+" classes, based on AvgMsPerTick"),log_helper_1.LogHelper.logTable(table),Game.flags.profile.remove()}static getProcessedClassData(classData,className,totalTicks){const result={className:className,avgMsUsagePerTick:0,functions:[]},functions=Object.keys(classData);for(let i=0;i<functions.length;i++){const f=functions[i],functionProcessed={functionName:f,avgMsUsagePerTick:0,callsPerTickAvg:0,avgTime:classData[f].average,callCount:classData[f].callCount};functionProcessed.callsPerTickAvg=classData[f].callCount/totalTicks,functionProcessed.avgMsUsagePerTick=functionProcessed.avgTime*functionProcessed.callsPerTickAvg,result.functions.push(functionProcessed),result.avgMsUsagePerTick+=functionProcessed.avgMsUsagePerTick}return result.functions.sort((a,b)=>b.avgMsUsagePerTick-a.avgMsUsagePerTick),result}};const SHOW_TOP_X_CLASSES=5,FIXED_NUMBER=5},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Profiler=void 0;exports.Profiler=class{static setup(thing,classString){const profiler=Memory.profiler;profiler[classString]={},Object.getOwnPropertyNames(thing).forEach(functionName=>{if(-1!==excludeList.indexOf(functionName))return;profiler[classString][functionName]={callCount:0,average:0};const originalFunction=thing[functionName];thing[functionName]=function(){const before=Game.cpu.getUsed();let result;0===arguments.length?result=originalFunction.call(thing):1===arguments.length?result=originalFunction.call(thing,arguments[0]):2===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1]):3===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1],arguments[2]):4===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1],arguments[2],arguments[3]):5===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]):6===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]):7===arguments.length?result=originalFunction.call(thing,arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]):console.log("ERROR87: "+arguments.length);const after=Game.cpu.getUsed();return Memory.profiler[classString][functionName].average=(Memory.profiler[classString][functionName].average*Memory.profiler[classString][functionName].callCount+(after-before))/(Memory.profiler[classString][functionName].callCount+1),Memory.profiler[classString][functionName].callCount+=1,result}})}};const excludeList=["prototype","length","name"]},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FunctionProfiler=void 0;const log_helper_1=__webpack_require__(1);exports.FunctionProfiler=class{static startFunction(functionName){null==Memory.functionProfiler[functionName]?Memory.functionProfiler[functionName]={callCount:1,average:0,before:Game.cpu.getUsed(),sections:{}}:Memory.functionProfiler[functionName].before=Game.cpu.getUsed()}static endFunction(functionName){Memory.functionProfiler[functionName].average=(Memory.functionProfiler[functionName].average*Memory.functionProfiler[functionName].callCount+(Game.cpu.getUsed()-Memory.functionProfiler[functionName].before))/(Memory.functionProfiler[functionName].callCount+1),Memory.functionProfiler[functionName].callCount++}static startFunctionSection(functionName,sectionName){null==Memory.functionProfiler[functionName].sections[sectionName]?Memory.functionProfiler[functionName].sections[sectionName]={callCount:1,average:0,before:Game.cpu.getUsed()}:Memory.functionProfiler[functionName].sections[sectionName].before=Game.cpu.getUsed()}static endFunctionSection(functionName,sectionName){Memory.functionProfiler[functionName].sections[sectionName].average=(Memory.functionProfiler[functionName].sections[sectionName].average*Memory.functionProfiler[functionName].sections[sectionName].callCount+(Game.cpu.getUsed()-Memory.functionProfiler[functionName].sections[sectionName].before))/(Memory.functionProfiler[functionName].sections[sectionName].callCount+1),Memory.functionProfiler[functionName].sections[sectionName].callCount++}static detectProfileReport(){if(null==Game.flags["profile-function"])return;const profile=Memory.functionProfiler;console.log("Function profiling report:");const totalTicks=Game.time-profile.startTick+1;console.log("TotalTicks: "+totalTicks);const table=[];table[0]=["Name","AvgMsPerTick","AvgCallsPerTick","AvgMsPerCall","Calls"];const functions=Object.keys(profile);functions.splice(functions.indexOf("startTick"),1);const processedFunctions=[];for(let i=0;i<functions.length;i++){const functionName=functions[i],processedFunction=this.getProcessedFunctionData(profile[functionName],functionName,totalTicks);processedFunctions.push(processedFunction)}processedFunctions.sort((a,b)=>b.avgMsUsagePerTick-a.avgMsUsagePerTick);let index=1;for(let i=0;i<SHOW_TOP_X_FUNCTIONS&&i<processedFunctions.length;i++){const processedFunction=processedFunctions[i];table[index]=[processedFunction.functionName,Number(processedFunction.avgMsUsagePerTick.toFixed(FIXED_NUMBER)).toString(),Number(processedFunction.callsPerTickAvg.toFixed(FIXED_NUMBER)).toString(),Number(processedFunction.avgTime.toFixed(FIXED_NUMBER)).toString(),processedFunction.callCount.toString()],index++;for(let j=0;j<processedFunction.sections.length;j++){const processedSection=processedFunction.sections[j];table[index]=[processedSection.sectionName,Number(processedSection.avgMsUsagePerTick.toFixed(FIXED_NUMBER)).toString(),Number(processedSection.callsPerTickAvg.toFixed(FIXED_NUMBER)).toString(),Number(processedSection.avgTime.toFixed(FIXED_NUMBER)).toString(),processedSection.callCount.toString()],index++}table[index]=["","","","",""],index++}console.log("Top "+SHOW_TOP_X_FUNCTIONS+" functions, based on AvgMsPerTick"),log_helper_1.LogHelper.logTable(table),Game.flags["profile-function"].remove()}static clearProfilingData(){Memory.functionProfiler={startTick:Game.time}}static getProcessedFunctionData(functionn,functionName,totalTicks){const result={functionName:functionName,avgMsUsagePerTick:0,callsPerTickAvg:0,avgTime:functionn.average,callCount:functionn.callCount,sections:[]};result.callsPerTickAvg=functionn.callCount/totalTicks,result.avgMsUsagePerTick=functionn.average*result.callsPerTickAvg;const sections=Object.keys(functionn.sections);for(let i=0;i<sections.length;i++){const sectionName=sections[i],sectionProcessed={sectionName:sectionName,avgMsUsagePerTick:0,callsPerTickAvg:0,avgTime:functionn.sections[sectionName].average,callCount:functionn.sections[sectionName].callCount};sectionProcessed.callsPerTickAvg=functionn.sections[sectionName].callCount/totalTicks,sectionProcessed.avgMsUsagePerTick=sectionProcessed.avgTime*sectionProcessed.callsPerTickAvg,result.sections.push(sectionProcessed)}return result.sections.sort((a,b)=>b.avgMsUsagePerTick-a.avgMsUsagePerTick),result}};const SHOW_TOP_X_FUNCTIONS=5,FIXED_NUMBER=5}]);